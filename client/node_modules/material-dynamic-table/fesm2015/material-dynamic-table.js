import { Component, ViewChild, Input, Directive, ViewContainerRef, ComponentFactoryResolver, NgModule } from '@angular/core';
import { MatSort, MatPaginator, MatDialog, MatDialogConfig, MatTableModule, MatSortModule, MatPaginatorModule, MatIconModule, MatDialogModule, MatTooltipModule } from '@angular/material';
import '@angular/cdk/table';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ColumnFilter {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ColumnFilterService {
    constructor() {
        this.registeredFilters = {};
    }
    /**
     * @param {?} type
     * @param {?} component
     * @return {?}
     */
    registerFilter(type, component) {
        this.registeredFilters[type] = component;
    }
    /**
     * @param {?} type
     * @return {?}
     */
    getFilter(type) {
        /** @type {?} */
        const component = this.registeredFilters[type];
        return component;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DynamicTableComponent {
    /**
     * @param {?} columnFilterService
     * @param {?} dialog
     */
    constructor(columnFilterService, dialog) {
        this.columnFilterService = columnFilterService;
        this.dialog = dialog;
        this.pageSize = 20;
        this.pageSizeOptions = [20, 50, 100];
        this.showFilters = true;
        this.stickyHeader = false;
        this.appliedFilters = {};
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.dataSource == null) {
            throw Error('DynamicTable must be provided with data source.');
        }
        if (this.columns == null) {
            throw Error('DynamicTable must be provided with column definitions.');
        }
        if (this.paginator === undefined) {
            this.paginator = this.internalPaginator;
        }
        this.displayedColumns = this.columns.map((column, index) => this.prepareColumnName(column.name, index));
        /** @type {?} */
        const dataSource = (/** @type {?} */ (this.dataSource));
        dataSource.sort = this.sort;
        dataSource.paginator = this.paginator;
    }
    /**
     * @return {?}
     */
    isUsingInternalPaginator() {
        return this.paginator === this.internalPaginator;
    }
    /**
     * @param {?} column
     * @return {?}
     */
    canFilter(column) {
        /** @type {?} */
        const filter = this.columnFilterService.getFilter(column.type);
        return filter != null;
    }
    /**
     * @param {?} column
     * @return {?}
     */
    isFiltered(column) {
        return this.appliedFilters[column.name];
    }
    /**
     * @param {?} column
     * @return {?}
     */
    getFilterDescription(column) {
        /** @type {?} */
        const filter = this.appliedFilters[column.name];
        if (!filter || !filter.getDescription) {
            return null;
        }
        return filter.getDescription();
    }
    /**
     * @param {?} name
     * @param {?} columnNumber
     * @return {?}
     */
    prepareColumnName(name, columnNumber) {
        return name || 'col' + columnNumber;
    }
    /**
     * @param {?} column
     * @return {?}
     */
    filter(column) {
        /** @type {?} */
        const filter = this.columnFilterService.getFilter(column.type);
        if (filter) {
            /** @type {?} */
            const dialogConfig = new MatDialogConfig();
            /** @type {?} */
            const columnFilter = new ColumnFilter();
            columnFilter.column = column;
            if (this.appliedFilters[column.name]) {
                columnFilter.filter = Object.create(this.appliedFilters[column.name]);
            }
            dialogConfig.data = columnFilter;
            /** @type {?} */
            const dialogRef = this.dialog.open(filter, dialogConfig);
            dialogRef.afterClosed().subscribe(result => {
                if (result) {
                    this.appliedFilters[column.name] = result;
                }
                else if (result === '') {
                    delete this.appliedFilters[column.name];
                }
                if (result || result === '') {
                    this.updateDataSource();
                }
            });
        }
    }
    /**
     * @return {?}
     */
    clearFilters() {
        this.appliedFilters = {};
        this.updateDataSource();
    }
    /**
     * @protected
     * @return {?}
     */
    updateDataSource() {
        /** @type {?} */
        const dataSource = (/** @type {?} */ (this.dataSource));
        dataSource.filters = this.getFilters();
    }
    /**
     * @return {?}
     */
    getFilters() {
        /** @type {?} */
        const filters = this.appliedFilters;
        /** @type {?} */
        const filterArray = Object.keys(filters).map((key) => filters[key]);
        return filterArray;
    }
    /**
     * @param {?} columnName
     * @return {?}
     */
    getFilter(columnName) {
        /** @type {?} */
        const filterColumn = this.getColumnByName(columnName);
        if (!filterColumn) {
            throw Error(`Column with name '${columnName}' does not exist.`);
        }
        return this.appliedFilters[filterColumn.name];
    }
    /**
     * @param {?} columnName
     * @param {?} filter
     * @return {?}
     */
    setFilter(columnName, filter) {
        /** @type {?} */
        const filterColumn = this.getColumnByName(columnName);
        if (!filterColumn) {
            throw Error(`Cannot set filter for a column. Column with name '${columnName}' does not exist.`);
        }
        this.appliedFilters[filterColumn.name] = filter;
        this.updateDataSource();
    }
    /**
     * @private
     * @param {?} columnName
     * @return {?}
     */
    getColumnByName(columnName) {
        return this.columns.find(c => (c.name ? c.name.toLowerCase() : c.name) === (columnName ? columnName.toLowerCase() : columnName));
    }
}
DynamicTableComponent.decorators = [
    { type: Component, args: [{
                selector: 'mdt-dynamic-table',
                template: "<table mat-table [dataSource]=\"dataSource\"\r\n       matSort matSortDirection=\"asc\">\r\n\r\n  <ng-container *ngFor=\"let column of columns; let i = index\" matColumnDef=\"{{ prepareColumnName(column.name, i) }}\"\r\n                [sticky]=\"column.sticky === 'start'\" [stickyEnd]=\"column.sticky === 'end'\">\r\n    <th mat-header-cell *matHeaderCellDef mat-sort-header=\"{{ prepareColumnName(column.name, i) }}\" [disabled]=\"!column.name || column.sort === false\">\r\n      {{ column.displayName }}\r\n      <button class=\"mat-sort-header-button\" *ngIf=\"showFilters && canFilter(column)\"\r\n              (click)=\"filter(column); $event.stopPropagation();\"\r\n              matTooltip=\"{{ getFilterDescription(column) }}\" matTooltipDisabled=\"{{ !getFilterDescription(column) }}\">\r\n        <mat-icon color=\"{{ isFiltered(column) ? 'primary' : 'default' }}\">filter_list</mat-icon>\r\n      </button>\r\n    </th>\r\n    <td mat-cell *matCellDef=\"let row\"><mdt-table-cell [row]=\"row\" [column]=\"column\"></mdt-table-cell></td>\r\n  </ng-container>\r\n\r\n  <tr mat-header-row *matHeaderRowDef=\"displayedColumns; sticky: [stickyHeader]\"></tr>\r\n  <tr mat-row *matRowDef=\"let row; columns: displayedColumns;\"></tr>\r\n</table>\r\n<mat-paginator [hidden]=\"!isUsingInternalPaginator()\" [pageSize]=\"pageSize\"\r\n               [pageSizeOptions]=\"pageSizeOptions\">\r\n</mat-paginator>",
                styles: ["table{width:100%}th .mat-icon.mat-default{opacity:.54}th .mat-icon.mat-default:hover{opacity:1}[hidden]{display:none}"]
            }] }
];
/** @nocollapse */
DynamicTableComponent.ctorParameters = () => [
    { type: ColumnFilterService },
    { type: MatDialog }
];
DynamicTableComponent.propDecorators = {
    columns: [{ type: Input }],
    dataSource: [{ type: Input }],
    pageSize: [{ type: Input }],
    pageSizeOptions: [{ type: Input }],
    showFilters: [{ type: Input }],
    stickyHeader: [{ type: Input }],
    paginator: [{ type: Input }],
    sort: [{ type: ViewChild, args: [MatSort,] }],
    internalPaginator: [{ type: ViewChild, args: [MatPaginator,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CellDirective {
    /**
     * @param {?} viewContainerRef
     */
    constructor(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
    }
}
CellDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mdtCellHost]',
            },] }
];
/** @nocollapse */
CellDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ColumnConfig {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TextCellComponent {
}
TextCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'mdt-text-cell',
                template: '{{ row[column.name] }}'
            }] }
];
TextCellComponent.propDecorators = {
    column: [{ type: Input }],
    row: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CellService {
    constructor() {
        this.registeredCells = {};
    }
    /**
     * @param {?} type
     * @param {?} component
     * @return {?}
     */
    registerCell(type, component) {
        this.registeredCells[type] = component;
    }
    /**
     * @param {?} type
     * @return {?}
     */
    getCell(type) {
        /** @type {?} */
        const component = this.registeredCells[type];
        if (component == null) {
            return TextCellComponent;
        }
        return component;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TableCellComponent {
    /**
     * @param {?} cellService
     * @param {?} componentFactoryResolver
     */
    constructor(cellService, componentFactoryResolver) {
        this.cellService = cellService;
        this.componentFactoryResolver = componentFactoryResolver;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.initCell();
    }
    /**
     * @return {?}
     */
    initCell() {
        /** @type {?} */
        const cellComponent = this.cellService.getCell(this.column.type);
        /** @type {?} */
        const componentFactory = this.componentFactoryResolver.resolveComponentFactory(cellComponent);
        /** @type {?} */
        const viewContainerRef = this.cellHost.viewContainerRef;
        viewContainerRef.clear();
        /** @type {?} */
        const componentRef = viewContainerRef.createComponent(componentFactory);
        /** @type {?} */
        const cell = (/** @type {?} */ (componentRef.instance));
        cell.row = this.row;
        cell.column = this.column;
    }
}
TableCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'mdt-table-cell',
                template: '<ng-template mdtCellHost></ng-template>'
            }] }
];
/** @nocollapse */
TableCellComponent.ctorParameters = () => [
    { type: CellService },
    { type: ComponentFactoryResolver }
];
TableCellComponent.propDecorators = {
    cellHost: [{ type: ViewChild, args: [CellDirective,] }],
    row: [{ type: Input }],
    column: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DateCellComponent {
    constructor() {
        this.dateFormat = 'short';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.column.options) {
            if (this.column.options.dateFormat) {
                this.dateFormat = this.column.options.dateFormat;
            }
        }
    }
}
DateCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'mdt-date-cell',
                template: '{{ row[column.name] | date:dateFormat }}'
            }] }
];
DateCellComponent.propDecorators = {
    column: [{ type: Input }],
    row: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DynamicTableModule {
    /**
     * @param {?} cellService
     */
    constructor(cellService) {
        this.cellService = cellService;
        cellService.registerCell('string', TextCellComponent);
        cellService.registerCell('date', DateCellComponent);
    }
}
DynamicTableModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MatTableModule,
                    MatSortModule,
                    MatPaginatorModule,
                    MatIconModule,
                    MatDialogModule,
                    MatTooltipModule
                ],
                declarations: [
                    DynamicTableComponent,
                    TableCellComponent,
                    CellDirective,
                    TextCellComponent,
                    DateCellComponent
                ],
                exports: [DynamicTableComponent],
                entryComponents: [
                    TextCellComponent,
                    DateCellComponent
                ],
                providers: [
                    CellService,
                    ColumnFilterService
                ]
            },] }
];
/** @nocollapse */
DynamicTableModule.ctorParameters = () => [
    { type: CellService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { DynamicTableComponent, CellService, CellDirective, ColumnFilterService, ColumnFilter, ColumnConfig, DynamicTableModule, DateCellComponent as ɵc, TextCellComponent as ɵb, TableCellComponent as ɵa };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0ZXJpYWwtZHluYW1pYy10YWJsZS5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vbWF0ZXJpYWwtZHluYW1pYy10YWJsZS9saWIvY29sdW1uLWZpbHRlci5tb2RlbC50cyIsIm5nOi8vbWF0ZXJpYWwtZHluYW1pYy10YWJsZS9saWIvdGFibGUtY2VsbC9jZWxsLXR5cGVzL2NvbHVtbi1maWx0ZXIuc2VydmljZS50cyIsIm5nOi8vbWF0ZXJpYWwtZHluYW1pYy10YWJsZS9saWIvZHluYW1pYy10YWJsZS5jb21wb25lbnQudHMiLCJuZzovL21hdGVyaWFsLWR5bmFtaWMtdGFibGUvbGliL3RhYmxlLWNlbGwvY2VsbC5kaXJlY3RpdmUudHMiLCJuZzovL21hdGVyaWFsLWR5bmFtaWMtdGFibGUvbGliL2NvbHVtbi1jb25maWcubW9kZWwudHMiLCJuZzovL21hdGVyaWFsLWR5bmFtaWMtdGFibGUvbGliL3RhYmxlLWNlbGwvY2VsbC10eXBlcy90ZXh0LWNlbGwuY29tcG9uZW50LnRzIiwibmc6Ly9tYXRlcmlhbC1keW5hbWljLXRhYmxlL2xpYi90YWJsZS1jZWxsL2NlbGwtdHlwZXMvY2VsbC5zZXJ2aWNlLnRzIiwibmc6Ly9tYXRlcmlhbC1keW5hbWljLXRhYmxlL2xpYi90YWJsZS1jZWxsL3RhYmxlLWNlbGwuY29tcG9uZW50LnRzIiwibmc6Ly9tYXRlcmlhbC1keW5hbWljLXRhYmxlL2xpYi90YWJsZS1jZWxsL2NlbGwtdHlwZXMvZGF0ZS1jZWxsLmNvbXBvbmVudC50cyIsIm5nOi8vbWF0ZXJpYWwtZHluYW1pYy10YWJsZS9saWIvZHluYW1pYy10YWJsZS5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29sdW1uQ29uZmlnIH0gZnJvbSAnLi9jb2x1bW4tY29uZmlnLm1vZGVsJztcblxuZXhwb3J0IGNsYXNzIENvbHVtbkZpbHRlciB7XG4gICAgY29sdW1uOiBDb2x1bW5Db25maWc7XG4gICAgZmlsdGVyOiBhbnk7XG59IiwiaW1wb3J0IHsgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5leHBvcnQgY2xhc3MgQ29sdW1uRmlsdGVyU2VydmljZSB7XG5cbiAgICBwcml2YXRlIHJlZ2lzdGVyZWRGaWx0ZXJzOiB7IFtrZXk6IHN0cmluZ106IFR5cGU8YW55PjsgfSA9IHt9O1xuICAgIFxuICAgIHJlZ2lzdGVyRmlsdGVyKHR5cGU6IHN0cmluZywgY29tcG9uZW50OiBUeXBlPGFueT4pIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRmlsdGVyc1t0eXBlXSA9IGNvbXBvbmVudDtcbiAgICB9XG5cbiAgICBnZXRGaWx0ZXIodHlwZTogc3RyaW5nKTogVHlwZTxhbnk+IHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gdGhpcy5yZWdpc3RlcmVkRmlsdGVyc1t0eXBlXTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgfVxufSIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBWaWV3Q2hpbGQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNYXRTb3J0LCBNYXRQYWdpbmF0b3IsIE1hdERpYWxvZywgTWF0RGlhbG9nQ29uZmlnIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xuaW1wb3J0IHsgRGF0YVNvdXJjZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay90YWJsZSc7XG5pbXBvcnQgeyBDb2x1bW5Db25maWcgfSBmcm9tICcuL2NvbHVtbi1jb25maWcubW9kZWwnO1xuaW1wb3J0IHsgQ29sdW1uRmlsdGVyIH0gZnJvbSAnLi9jb2x1bW4tZmlsdGVyLm1vZGVsJztcbmltcG9ydCB7IENvbHVtbkZpbHRlclNlcnZpY2UgfSBmcm9tICcuL3RhYmxlLWNlbGwvY2VsbC10eXBlcy9jb2x1bW4tZmlsdGVyLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdtZHQtZHluYW1pYy10YWJsZScsXG4gIHRlbXBsYXRlVXJsOiAnLi9keW5hbWljLXRhYmxlLmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJy4vZHluYW1pYy10YWJsZS5jb21wb25lbnQuY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgRHluYW1pY1RhYmxlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICBASW5wdXQoKSBjb2x1bW5zOiBDb2x1bW5Db25maWdbXTtcbiAgQElucHV0KCkgZGF0YVNvdXJjZTogRGF0YVNvdXJjZTxhbnk+O1xuICBASW5wdXQoKSBwYWdlU2l6ZSA9IDIwO1xuICBASW5wdXQoKSBwYWdlU2l6ZU9wdGlvbnMgPSBbMjAsIDUwLCAxMDBdO1xuICBASW5wdXQoKSBzaG93RmlsdGVycyA9IHRydWU7XG4gIEBJbnB1dCgpIHN0aWNreUhlYWRlciA9IGZhbHNlO1xuICBASW5wdXQoKSBwYWdpbmF0b3I6IE1hdFBhZ2luYXRvcjtcblxuICBkaXNwbGF5ZWRDb2x1bW5zOiBzdHJpbmdbXTtcblxuICBAVmlld0NoaWxkKE1hdFNvcnQpIHNvcnQ6IE1hdFNvcnQ7XG4gIEBWaWV3Q2hpbGQoTWF0UGFnaW5hdG9yKSBwcml2YXRlIGludGVybmFsUGFnaW5hdG9yOiBNYXRQYWdpbmF0b3I7XG5cbiAgcHJpdmF0ZSBhcHBsaWVkRmlsdGVyczogeyBba2V5OiBzdHJpbmddOiBhbnk7IH0gPSB7fTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGNvbHVtbkZpbHRlclNlcnZpY2U6IENvbHVtbkZpbHRlclNlcnZpY2UsIHByaXZhdGUgcmVhZG9ubHkgZGlhbG9nOiBNYXREaWFsb2cpIHsgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIGlmICh0aGlzLmRhdGFTb3VyY2UgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0R5bmFtaWNUYWJsZSBtdXN0IGJlIHByb3ZpZGVkIHdpdGggZGF0YSBzb3VyY2UuJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbHVtbnMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0R5bmFtaWNUYWJsZSBtdXN0IGJlIHByb3ZpZGVkIHdpdGggY29sdW1uIGRlZmluaXRpb25zLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhZ2luYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnBhZ2luYXRvciA9IHRoaXMuaW50ZXJuYWxQYWdpbmF0b3I7XG4gICAgfVxuXG4gICAgdGhpcy5kaXNwbGF5ZWRDb2x1bW5zID0gdGhpcy5jb2x1bW5zLm1hcCgoY29sdW1uLCBpbmRleCkgPT4gdGhpcy5wcmVwYXJlQ29sdW1uTmFtZShjb2x1bW4ubmFtZSwgaW5kZXgpKTtcblxuICAgIGNvbnN0IGRhdGFTb3VyY2UgPSB0aGlzLmRhdGFTb3VyY2UgYXMgYW55O1xuICAgIGRhdGFTb3VyY2Uuc29ydCA9IHRoaXMuc29ydDtcbiAgICBkYXRhU291cmNlLnBhZ2luYXRvciA9IHRoaXMucGFnaW5hdG9yO1xuICB9XG5cbiAgaXNVc2luZ0ludGVybmFsUGFnaW5hdG9yKCkge1xuICAgIHJldHVybiB0aGlzLnBhZ2luYXRvciA9PT0gdGhpcy5pbnRlcm5hbFBhZ2luYXRvcjtcbiAgfVxuXG4gIGNhbkZpbHRlcihjb2x1bW46IENvbHVtbkNvbmZpZykge1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuY29sdW1uRmlsdGVyU2VydmljZS5nZXRGaWx0ZXIoY29sdW1uLnR5cGUpO1xuXG4gICAgcmV0dXJuIGZpbHRlciAhPSBudWxsO1xuICB9XG5cbiAgaXNGaWx0ZXJlZChjb2x1bW46IENvbHVtbkNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmFwcGxpZWRGaWx0ZXJzW2NvbHVtbi5uYW1lXTtcbiAgfVxuXG4gIGdldEZpbHRlckRlc2NyaXB0aW9uKGNvbHVtbjogQ29sdW1uQ29uZmlnKSB7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy5hcHBsaWVkRmlsdGVyc1tjb2x1bW4ubmFtZV07XG4gICAgaWYgKCFmaWx0ZXIgfHwgIWZpbHRlci5nZXREZXNjcmlwdGlvbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbHRlci5nZXREZXNjcmlwdGlvbigpO1xuICB9XG5cbiAgcHJlcGFyZUNvbHVtbk5hbWUobmFtZTogc3RyaW5nLCBjb2x1bW5OdW1iZXI6IG51bWJlcikge1xuICAgIHJldHVybiBuYW1lIHx8ICdjb2wnICsgY29sdW1uTnVtYmVyO1xuICB9XG5cbiAgZmlsdGVyKGNvbHVtbjogQ29sdW1uQ29uZmlnKSB7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy5jb2x1bW5GaWx0ZXJTZXJ2aWNlLmdldEZpbHRlcihjb2x1bW4udHlwZSk7XG5cbiAgICBpZiAoZmlsdGVyKSB7XG4gICAgICBjb25zdCBkaWFsb2dDb25maWcgPSBuZXcgTWF0RGlhbG9nQ29uZmlnKCk7XG4gICAgICBjb25zdCBjb2x1bW5GaWx0ZXIgPSBuZXcgQ29sdW1uRmlsdGVyKCk7XG4gICAgICBjb2x1bW5GaWx0ZXIuY29sdW1uID0gY29sdW1uO1xuXG4gICAgICBpZiAodGhpcy5hcHBsaWVkRmlsdGVyc1tjb2x1bW4ubmFtZV0pIHtcbiAgICAgICAgY29sdW1uRmlsdGVyLmZpbHRlciA9IE9iamVjdC5jcmVhdGUodGhpcy5hcHBsaWVkRmlsdGVyc1tjb2x1bW4ubmFtZV0pO1xuICAgICAgfVxuXG4gICAgICBkaWFsb2dDb25maWcuZGF0YSA9IGNvbHVtbkZpbHRlcjtcblxuICAgICAgY29uc3QgZGlhbG9nUmVmID0gdGhpcy5kaWFsb2cub3BlbihmaWx0ZXIsIGRpYWxvZ0NvbmZpZyk7XG5cbiAgICAgIGRpYWxvZ1JlZi5hZnRlckNsb3NlZCgpLnN1YnNjcmliZShyZXN1bHQgPT4ge1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgdGhpcy5hcHBsaWVkRmlsdGVyc1tjb2x1bW4ubmFtZV0gPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ID09PSAnJykge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmFwcGxpZWRGaWx0ZXJzW2NvbHVtbi5uYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQgfHwgcmVzdWx0ID09PSAnJykge1xuICAgICAgICAgIHRoaXMudXBkYXRlRGF0YVNvdXJjZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBjbGVhckZpbHRlcnMoKSB7XG4gICAgdGhpcy5hcHBsaWVkRmlsdGVycyA9IHt9O1xuICAgIHRoaXMudXBkYXRlRGF0YVNvdXJjZSgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHVwZGF0ZURhdGFTb3VyY2UoKSB7XG4gICAgY29uc3QgZGF0YVNvdXJjZSA9IHRoaXMuZGF0YVNvdXJjZSBhcyBhbnk7XG4gICAgZGF0YVNvdXJjZS5maWx0ZXJzID0gdGhpcy5nZXRGaWx0ZXJzKCk7XG4gIH1cblxuICBnZXRGaWx0ZXJzKCkge1xuICAgIGNvbnN0IGZpbHRlcnMgPSB0aGlzLmFwcGxpZWRGaWx0ZXJzO1xuICAgIGNvbnN0IGZpbHRlckFycmF5ID0gT2JqZWN0LmtleXMoZmlsdGVycykubWFwKChrZXkpID0+IGZpbHRlcnNba2V5XSk7XG4gICAgcmV0dXJuIGZpbHRlckFycmF5O1xuICB9XG5cbiAgZ2V0RmlsdGVyKGNvbHVtbk5hbWU6IHN0cmluZyk6IGFueSB7XG4gICAgY29uc3QgZmlsdGVyQ29sdW1uID0gdGhpcy5nZXRDb2x1bW5CeU5hbWUoY29sdW1uTmFtZSk7XG5cbiAgICBpZiAoIWZpbHRlckNvbHVtbikge1xuICAgICAgdGhyb3cgRXJyb3IoYENvbHVtbiB3aXRoIG5hbWUgJyR7Y29sdW1uTmFtZX0nIGRvZXMgbm90IGV4aXN0LmApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFwcGxpZWRGaWx0ZXJzW2ZpbHRlckNvbHVtbi5uYW1lXTtcbiAgfVxuXG4gIHNldEZpbHRlcihjb2x1bW5OYW1lOiBzdHJpbmcsIGZpbHRlcjogYW55KSB7XG4gICAgY29uc3QgZmlsdGVyQ29sdW1uID0gdGhpcy5nZXRDb2x1bW5CeU5hbWUoY29sdW1uTmFtZSk7XG5cbiAgICBpZiAoIWZpbHRlckNvbHVtbikge1xuICAgICAgdGhyb3cgRXJyb3IoYENhbm5vdCBzZXQgZmlsdGVyIGZvciBhIGNvbHVtbi4gQ29sdW1uIHdpdGggbmFtZSAnJHtjb2x1bW5OYW1lfScgZG9lcyBub3QgZXhpc3QuYCk7XG4gICAgfVxuXG4gICAgdGhpcy5hcHBsaWVkRmlsdGVyc1tmaWx0ZXJDb2x1bW4ubmFtZV0gPSBmaWx0ZXI7XG4gICAgdGhpcy51cGRhdGVEYXRhU291cmNlKCk7XG4gIH1cblxuICBwcml2YXRlIGdldENvbHVtbkJ5TmFtZShjb2x1bW5OYW1lOiBzdHJpbmcpOiBDb2x1bW5Db25maWcge1xuICAgIHJldHVybiB0aGlzLmNvbHVtbnMuZmluZChjID0+XG4gICAgICAoYy5uYW1lID8gYy5uYW1lLnRvTG93ZXJDYXNlKCkgOiBjLm5hbWUpID09PSAoY29sdW1uTmFtZSA/IGNvbHVtbk5hbWUudG9Mb3dlckNhc2UoKSA6IGNvbHVtbk5hbWUpXG4gICAgKTtcbiAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1ttZHRDZWxsSG9zdF0nLFxufSlcbmV4cG9ydCBjbGFzcyBDZWxsRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZikge31cbn0iLCJleHBvcnQgY2xhc3MgQ29sdW1uQ29uZmlnIHtcclxuICAgIG5hbWU/OiBzdHJpbmc7XHJcbiAgICBkaXNwbGF5TmFtZT86IHN0cmluZztcclxuICAgIHR5cGU6IHN0cmluZztcclxuICAgIG9wdGlvbnM/OiBhbnk7XHJcbiAgICBzdGlja3k/OiBzdHJpbmc7XHJcbiAgICBzb3J0PzogYm9vbGVhbjtcclxufSIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENlbGxDb21wb25lbnQgfSBmcm9tICcuL2NlbGwuY29tcG9uZW50JztcbmltcG9ydCB7IENvbHVtbkNvbmZpZyB9IGZyb20gJy4uLy4uL2NvbHVtbi1jb25maWcubW9kZWwnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ21kdC10ZXh0LWNlbGwnLFxuICAgIHRlbXBsYXRlOiAne3sgcm93W2NvbHVtbi5uYW1lXSB9fSdcbn0pXG5leHBvcnQgY2xhc3MgVGV4dENlbGxDb21wb25lbnQgaW1wbGVtZW50cyBDZWxsQ29tcG9uZW50IHtcbiAgICBASW5wdXQoKSBjb2x1bW46IENvbHVtbkNvbmZpZztcbiAgICBASW5wdXQoKSByb3c6IG9iamVjdDtcbn0iLCJpbXBvcnQgeyBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUZXh0Q2VsbENvbXBvbmVudCB9IGZyb20gJy4vdGV4dC1jZWxsLmNvbXBvbmVudCc7XG5cbmV4cG9ydCBjbGFzcyBDZWxsU2VydmljZSB7XG5cbiAgICBwcml2YXRlIHJlZ2lzdGVyZWRDZWxsczogeyBba2V5OiBzdHJpbmddOiBUeXBlPGFueT47IH0gPSB7fTtcbiAgICBcbiAgICByZWdpc3RlckNlbGwodHlwZTogc3RyaW5nLCBjb21wb25lbnQ6IFR5cGU8YW55Pikge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRDZWxsc1t0eXBlXSA9IGNvbXBvbmVudDtcbiAgICB9XG5cbiAgICBnZXRDZWxsKHR5cGU6IHN0cmluZyk6IFR5cGU8YW55PiB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMucmVnaXN0ZXJlZENlbGxzW3R5cGVdO1xuXG4gICAgICAgIGlmIChjb21wb25lbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFRleHRDZWxsQ29tcG9uZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIElucHV0LCBWaWV3Q2hpbGQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2VsbERpcmVjdGl2ZSB9IGZyb20gJy4vY2VsbC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgQ2VsbFNlcnZpY2UgfSBmcm9tICcuL2NlbGwtdHlwZXMvY2VsbC5zZXJ2aWNlJztcbmltcG9ydCB7IENlbGxDb21wb25lbnQgfSBmcm9tICcuL2NlbGwtdHlwZXMvY2VsbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29sdW1uQ29uZmlnIH0gZnJvbSAnLi4vY29sdW1uLWNvbmZpZy5tb2RlbCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnbWR0LXRhYmxlLWNlbGwnLFxuICAgIHRlbXBsYXRlOiAnPG5nLXRlbXBsYXRlIG1kdENlbGxIb3N0PjwvbmctdGVtcGxhdGU+J1xufSlcbmV4cG9ydCBjbGFzcyBUYWJsZUNlbGxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICAgIEBWaWV3Q2hpbGQoQ2VsbERpcmVjdGl2ZSkgY2VsbEhvc3Q6IENlbGxEaXJlY3RpdmU7XG5cbiAgICBASW5wdXQoKSByb3c6IG9iamVjdDtcbiAgICBASW5wdXQoKSBjb2x1bW46IENvbHVtbkNvbmZpZztcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IGNlbGxTZXJ2aWNlOiBDZWxsU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcikgeyB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5pbml0Q2VsbCgpO1xuICAgIH1cblxuICAgIGluaXRDZWxsKCkge1xuICAgICAgICBjb25zdCBjZWxsQ29tcG9uZW50ID0gdGhpcy5jZWxsU2VydmljZS5nZXRDZWxsKHRoaXMuY29sdW1uLnR5cGUpO1xuICAgICAgICBjb25zdCBjb21wb25lbnRGYWN0b3J5ID0gdGhpcy5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoY2VsbENvbXBvbmVudCk7XG4gICAgICAgIGNvbnN0IHZpZXdDb250YWluZXJSZWYgPSB0aGlzLmNlbGxIb3N0LnZpZXdDb250YWluZXJSZWY7XG4gICAgICAgIHZpZXdDb250YWluZXJSZWYuY2xlYXIoKTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50UmVmID0gdmlld0NvbnRhaW5lclJlZi5jcmVhdGVDb21wb25lbnQoY29tcG9uZW50RmFjdG9yeSk7XG4gICAgICAgIGNvbnN0IGNlbGwgPSBjb21wb25lbnRSZWYuaW5zdGFuY2UgYXMgQ2VsbENvbXBvbmVudDtcbiAgICAgICAgY2VsbC5yb3cgPSB0aGlzLnJvdztcbiAgICAgICAgY2VsbC5jb2x1bW4gPSB0aGlzLmNvbHVtbjtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDZWxsQ29tcG9uZW50IH0gZnJvbSAnLi9jZWxsLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb2x1bW5Db25maWcgfSBmcm9tICcuLi8uLi9jb2x1bW4tY29uZmlnLm1vZGVsJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdtZHQtZGF0ZS1jZWxsJyxcbiAgICB0ZW1wbGF0ZTogJ3t7IHJvd1tjb2x1bW4ubmFtZV0gfCBkYXRlOmRhdGVGb3JtYXQgfX0nXG59KVxuZXhwb3J0IGNsYXNzIERhdGVDZWxsQ29tcG9uZW50IGltcGxlbWVudHMgQ2VsbENvbXBvbmVudCwgT25Jbml0IHtcbiAgICBASW5wdXQoKSBjb2x1bW46IENvbHVtbkNvbmZpZztcbiAgICBASW5wdXQoKSByb3c6IG9iamVjdDtcblxuICAgIGRhdGVGb3JtYXQgPSAnc2hvcnQnO1xuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbi5vcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2x1bW4ub3B0aW9ucy5kYXRlRm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRlRm9ybWF0ID0gdGhpcy5jb2x1bW4ub3B0aW9ucy5kYXRlRm9ybWF0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5pbXBvcnQge1xuICBNYXRUYWJsZU1vZHVsZSxcbiAgTWF0U29ydE1vZHVsZSxcbiAgTWF0UGFnaW5hdG9yTW9kdWxlLFxuICBNYXRJY29uTW9kdWxlLFxuICBNYXREaWFsb2dNb2R1bGUsXG4gIE1hdFRvb2x0aXBNb2R1bGVcbn0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xuXG5pbXBvcnQgeyBEeW5hbWljVGFibGVDb21wb25lbnQgfSBmcm9tICcuL2R5bmFtaWMtdGFibGUuY29tcG9uZW50JztcbmltcG9ydCB7IFRhYmxlQ2VsbENvbXBvbmVudCB9IGZyb20gJy4vdGFibGUtY2VsbC90YWJsZS1jZWxsLmNvbXBvbmVudCc7XG5cbmltcG9ydCB7IENlbGxTZXJ2aWNlIH0gZnJvbSAnLi90YWJsZS1jZWxsL2NlbGwtdHlwZXMvY2VsbC5zZXJ2aWNlJztcbmltcG9ydCB7IENlbGxEaXJlY3RpdmUgfSBmcm9tICcuL3RhYmxlLWNlbGwvY2VsbC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgQ29sdW1uRmlsdGVyU2VydmljZSB9IGZyb20gJy4vdGFibGUtY2VsbC9jZWxsLXR5cGVzL2NvbHVtbi1maWx0ZXIuc2VydmljZSc7XG5cbmV4cG9ydCB7IENlbGxTZXJ2aWNlLCBDZWxsRGlyZWN0aXZlLCBDb2x1bW5GaWx0ZXJTZXJ2aWNlIH07XG5leHBvcnQgeyBDZWxsQ29tcG9uZW50IH0gZnJvbSAnLi90YWJsZS1jZWxsL2NlbGwtdHlwZXMvY2VsbC5jb21wb25lbnQnO1xuZXhwb3J0IHsgQ29sdW1uRmlsdGVyIH0gZnJvbSAnLi9jb2x1bW4tZmlsdGVyLm1vZGVsJztcbmV4cG9ydCB7IENvbHVtbkNvbmZpZyB9IGZyb20gJy4vY29sdW1uLWNvbmZpZy5tb2RlbCc7XG5leHBvcnQgeyBGaWx0ZXJEZXNjcmlwdGlvbiB9IGZyb20gJy4vZmlsdGVyLWRlc2NyaXB0aW9uJztcblxuaW1wb3J0IHsgVGV4dENlbGxDb21wb25lbnQgfSBmcm9tICcuL3RhYmxlLWNlbGwvY2VsbC10eXBlcy90ZXh0LWNlbGwuY29tcG9uZW50JztcbmltcG9ydCB7IERhdGVDZWxsQ29tcG9uZW50IH0gZnJvbSAnLi90YWJsZS1jZWxsL2NlbGwtdHlwZXMvZGF0ZS1jZWxsLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtcbiAgICBDb21tb25Nb2R1bGUsXG4gICAgTWF0VGFibGVNb2R1bGUsXG4gICAgTWF0U29ydE1vZHVsZSxcbiAgICBNYXRQYWdpbmF0b3JNb2R1bGUsXG4gICAgTWF0SWNvbk1vZHVsZSxcbiAgICBNYXREaWFsb2dNb2R1bGUsXG4gICAgTWF0VG9vbHRpcE1vZHVsZVxuICBdLFxuICBkZWNsYXJhdGlvbnM6IFtcbiAgICBEeW5hbWljVGFibGVDb21wb25lbnQsXG4gICAgVGFibGVDZWxsQ29tcG9uZW50LFxuICAgIENlbGxEaXJlY3RpdmUsXG4gICAgVGV4dENlbGxDb21wb25lbnQsXG4gICAgRGF0ZUNlbGxDb21wb25lbnRcbiAgXSxcbiAgZXhwb3J0czogW0R5bmFtaWNUYWJsZUNvbXBvbmVudF0sXG4gIGVudHJ5Q29tcG9uZW50czogW1xuICAgIFRleHRDZWxsQ29tcG9uZW50LFxuICAgIERhdGVDZWxsQ29tcG9uZW50XG4gIF0sXG4gIHByb3ZpZGVyczogW1xuICAgIENlbGxTZXJ2aWNlLFxuICAgIENvbHVtbkZpbHRlclNlcnZpY2VcbiAgXVxufSlcbmV4cG9ydCBjbGFzcyBEeW5hbWljVGFibGVNb2R1bGUge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGNlbGxTZXJ2aWNlOiBDZWxsU2VydmljZSkge1xuICAgIGNlbGxTZXJ2aWNlLnJlZ2lzdGVyQ2VsbCgnc3RyaW5nJywgVGV4dENlbGxDb21wb25lbnQpO1xuICAgIGNlbGxTZXJ2aWNlLnJlZ2lzdGVyQ2VsbCgnZGF0ZScsIERhdGVDZWxsQ29tcG9uZW50KTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUVBLE1BQWEsWUFBWTtDQUd4Qjs7Ozs7O0FDSEQsTUFBYSxtQkFBbUI7SUFBaEM7UUFFWSxzQkFBaUIsR0FBa0MsRUFBRSxDQUFDO0tBV2pFOzs7Ozs7SUFURyxjQUFjLENBQUMsSUFBWSxFQUFFLFNBQW9CO1FBQzdDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsR0FBRyxTQUFTLENBQUM7S0FDNUM7Ozs7O0lBRUQsU0FBUyxDQUFDLElBQVk7O2NBQ1osU0FBUyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUM7UUFFOUMsT0FBTyxTQUFTLENBQUM7S0FDcEI7Q0FDSjs7Ozs7O0FDZkQsTUFZYSxxQkFBcUI7Ozs7O0lBaUJoQyxZQUE2QixtQkFBd0MsRUFBbUIsTUFBaUI7UUFBNUUsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUFxQjtRQUFtQixXQUFNLEdBQU4sTUFBTSxDQUFXO1FBYmhHLGFBQVEsR0FBRyxFQUFFLENBQUM7UUFDZCxvQkFBZSxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUNoQyxnQkFBVyxHQUFHLElBQUksQ0FBQztRQUNuQixpQkFBWSxHQUFHLEtBQUssQ0FBQztRQVF0QixtQkFBYyxHQUE0QixFQUFFLENBQUM7S0FFeUQ7Ozs7SUFFOUcsUUFBUTtRQUNOLElBQUksSUFBSSxDQUFDLFVBQVUsSUFBSSxJQUFJLEVBQUU7WUFDM0IsTUFBTSxLQUFLLENBQUMsaURBQWlELENBQUMsQ0FBQztTQUNoRTtRQUNELElBQUksSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLEVBQUU7WUFDeEIsTUFBTSxLQUFLLENBQUMsd0RBQXdELENBQUMsQ0FBQztT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