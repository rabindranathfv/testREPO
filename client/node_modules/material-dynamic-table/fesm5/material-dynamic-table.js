import { Component, ViewChild, Input, Directive, ViewContainerRef, ComponentFactoryResolver, NgModule } from '@angular/core';
import { MatSort, MatPaginator, MatDialog, MatDialogConfig, MatTableModule, MatSortModule, MatPaginatorModule, MatIconModule, MatDialogModule, MatTooltipModule } from '@angular/material';
import '@angular/cdk/table';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ColumnFilter = /** @class */ (function () {
    function ColumnFilter() {
    }
    return ColumnFilter;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ColumnFilterService = /** @class */ (function () {
    function ColumnFilterService() {
        this.registeredFilters = {};
    }
    /**
     * @param {?} type
     * @param {?} component
     * @return {?}
     */
    ColumnFilterService.prototype.registerFilter = /**
     * @param {?} type
     * @param {?} component
     * @return {?}
     */
    function (type, component) {
        this.registeredFilters[type] = component;
    };
    /**
     * @param {?} type
     * @return {?}
     */
    ColumnFilterService.prototype.getFilter = /**
     * @param {?} type
     * @return {?}
     */
    function (type) {
        /** @type {?} */
        var component = this.registeredFilters[type];
        return component;
    };
    return ColumnFilterService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DynamicTableComponent = /** @class */ (function () {
    function DynamicTableComponent(columnFilterService, dialog) {
        this.columnFilterService = columnFilterService;
        this.dialog = dialog;
        this.pageSize = 20;
        this.pageSizeOptions = [20, 50, 100];
        this.showFilters = true;
        this.stickyHeader = false;
        this.appliedFilters = {};
    }
    /**
     * @return {?}
     */
    DynamicTableComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.dataSource == null) {
            throw Error('DynamicTable must be provided with data source.');
        }
        if (this.columns == null) {
            throw Error('DynamicTable must be provided with column definitions.');
        }
        if (this.paginator === undefined) {
            this.paginator = this.internalPaginator;
        }
        this.displayedColumns = this.columns.map(function (column, index) { return _this.prepareColumnName(column.name, index); });
        /** @type {?} */
        var dataSource = (/** @type {?} */ (this.dataSource));
        dataSource.sort = this.sort;
        dataSource.paginator = this.paginator;
    };
    /**
     * @return {?}
     */
    DynamicTableComponent.prototype.isUsingInternalPaginator = /**
     * @return {?}
     */
    function () {
        return this.paginator === this.internalPaginator;
    };
    /**
     * @param {?} column
     * @return {?}
     */
    DynamicTableComponent.prototype.canFilter = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        /** @type {?} */
        var filter = this.columnFilterService.getFilter(column.type);
        return filter != null;
    };
    /**
     * @param {?} column
     * @return {?}
     */
    DynamicTableComponent.prototype.isFiltered = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        return this.appliedFilters[column.name];
    };
    /**
     * @param {?} column
     * @return {?}
     */
    DynamicTableComponent.prototype.getFilterDescription = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        /** @type {?} */
        var filter = this.appliedFilters[column.name];
        if (!filter || !filter.getDescription) {
            return null;
        }
        return filter.getDescription();
    };
    /**
     * @param {?} name
     * @param {?} columnNumber
     * @return {?}
     */
    DynamicTableComponent.prototype.prepareColumnName = /**
     * @param {?} name
     * @param {?} columnNumber
     * @return {?}
     */
    function (name, columnNumber) {
        return name || 'col' + columnNumber;
    };
    /**
     * @param {?} column
     * @return {?}
     */
    DynamicTableComponent.prototype.filter = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        var _this = this;
        /** @type {?} */
        var filter = this.columnFilterService.getFilter(column.type);
        if (filter) {
            /** @type {?} */
            var dialogConfig = new MatDialogConfig();
            /** @type {?} */
            var columnFilter = new ColumnFilter();
            columnFilter.column = column;
            if (this.appliedFilters[column.name]) {
                columnFilter.filter = Object.create(this.appliedFilters[column.name]);
            }
            dialogConfig.data = columnFilter;
            /** @type {?} */
            var dialogRef = this.dialog.open(filter, dialogConfig);
            dialogRef.afterClosed().subscribe(function (result) {
                if (result) {
                    _this.appliedFilters[column.name] = result;
                }
                else if (result === '') {
                    delete _this.appliedFilters[column.name];
                }
                if (result || result === '') {
                    _this.updateDataSource();
                }
            });
        }
    };
    /**
     * @return {?}
     */
    DynamicTableComponent.prototype.clearFilters = /**
     * @return {?}
     */
    function () {
        this.appliedFilters = {};
        this.updateDataSource();
    };
    /**
     * @protected
     * @return {?}
     */
    DynamicTableComponent.prototype.updateDataSource = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var dataSource = (/** @type {?} */ (this.dataSource));
        dataSource.filters = this.getFilters();
    };
    /**
     * @return {?}
     */
    DynamicTableComponent.prototype.getFilters = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var filters = this.appliedFilters;
        /** @type {?} */
        var filterArray = Object.keys(filters).map(function (key) { return filters[key]; });
        return filterArray;
    };
    /**
     * @param {?} columnName
     * @return {?}
     */
    DynamicTableComponent.prototype.getFilter = /**
     * @param {?} columnName
     * @return {?}
     */
    function (columnName) {
        /** @type {?} */
        var filterColumn = this.getColumnByName(columnName);
        if (!filterColumn) {
            throw Error("Column with name '" + columnName + "' does not exist.");
        }
        return this.appliedFilters[filterColumn.name];
    };
    /**
     * @param {?} columnName
     * @param {?} filter
     * @return {?}
     */
    DynamicTableComponent.prototype.setFilter = /**
     * @param {?} columnName
     * @param {?} filter
     * @return {?}
     */
    function (columnName, filter) {
        /** @type {?} */
        var filterColumn = this.getColumnByName(columnName);
        if (!filterColumn) {
            throw Error("Cannot set filter for a column. Column with name '" + columnName + "' does not exist.");
        }
        this.appliedFilters[filterColumn.name] = filter;
        this.updateDataSource();
    };
    /**
     * @private
     * @param {?} columnName
     * @return {?}
     */
    DynamicTableComponent.prototype.getColumnByName = /**
     * @private
     * @param {?} columnName
     * @return {?}
     */
    function (columnName) {
        return this.columns.find(function (c) {
            return (c.name ? c.name.toLowerCase() : c.name) === (columnName ? columnName.toLowerCase() : columnName);
        });
    };
    DynamicTableComponent.decorators = [
        { type: Component, args: [{
                    selector: 'mdt-dynamic-table',
                    template: "<table mat-table [dataSource]=\"dataSource\"\r\n       matSort matSortDirection=\"asc\">\r\n\r\n  <ng-container *ngFor=\"let column of columns; let i = index\" matColumnDef=\"{{ prepareColumnName(column.name, i) }}\"\r\n                [sticky]=\"column.sticky === 'start'\" [stickyEnd]=\"column.sticky === 'end'\">\r\n    <th mat-header-cell *matHeaderCellDef mat-sort-header=\"{{ prepareColumnName(column.name, i) }}\" [disabled]=\"!column.name || column.sort === false\">\r\n      {{ column.displayName }}\r\n      <button class=\"mat-sort-header-button\" *ngIf=\"showFilters && canFilter(column)\"\r\n              (click)=\"filter(column); $event.stopPropagation();\"\r\n              matTooltip=\"{{ getFilterDescription(column) }}\" matTooltipDisabled=\"{{ !getFilterDescription(column) }}\">\r\n        <mat-icon color=\"{{ isFiltered(column) ? 'primary' : 'default' }}\">filter_list</mat-icon>\r\n      </button>\r\n    </th>\r\n    <td mat-cell *matCellDef=\"let row\"><mdt-table-cell [row]=\"row\" [column]=\"column\"></mdt-table-cell></td>\r\n  </ng-container>\r\n\r\n  <tr mat-header-row *matHeaderRowDef=\"displayedColumns; sticky: [stickyHeader]\"></tr>\r\n  <tr mat-row *matRowDef=\"let row; columns: displayedColumns;\"></tr>\r\n</table>\r\n<mat-paginator [hidden]=\"!isUsingInternalPaginator()\" [pageSize]=\"pageSize\"\r\n               [pageSizeOptions]=\"pageSizeOptions\">\r\n</mat-paginator>",
                    styles: ["table{width:100%}th .mat-icon.mat-default{opacity:.54}th .mat-icon.mat-default:hover{opacity:1}[hidden]{display:none}"]
                }] }
    ];
    /** @nocollapse */
    DynamicTableComponent.ctorParameters = function () { return [
        { type: ColumnFilterService },
        { type: MatDialog }
    ]; };
    DynamicTableComponent.propDecorators = {
        columns: [{ type: Input }],
        dataSource: [{ type: Input }],
        pageSize: [{ type: Input }],
        pageSizeOptions: [{ type: Input }],
        showFilters: [{ type: Input }],
        stickyHeader: [{ type: Input }],
        paginator: [{ type: Input }],
        sort: [{ type: ViewChild, args: [MatSort,] }],
        internalPaginator: [{ type: ViewChild, args: [MatPaginator,] }]
    };
    return DynamicTableComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var CellDirective = /** @class */ (function () {
    function CellDirective(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
    }
    CellDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[mdtCellHost]',
                },] }
    ];
    /** @nocollapse */
    CellDirective.ctorParameters = function () { return [
        { type: ViewContainerRef }
    ]; };
    return CellDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ColumnConfig = /** @class */ (function () {
    function ColumnConfig() {
    }
    return ColumnConfig;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TextCellComponent = /** @class */ (function () {
    function TextCellComponent() {
    }
    TextCellComponent.decorators = [
        { type: Component, args: [{
                    selector: 'mdt-text-cell',
                    template: '{{ row[column.name] }}'
                }] }
    ];
    TextCellComponent.propDecorators = {
        column: [{ type: Input }],
        row: [{ type: Input }]
    };
    return TextCellComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var CellService = /** @class */ (function () {
    function CellService() {
        this.registeredCells = {};
    }
    /**
     * @param {?} type
     * @param {?} component
     * @return {?}
     */
    CellService.prototype.registerCell = /**
     * @param {?} type
     * @param {?} component
     * @return {?}
     */
    function (type, component) {
        this.registeredCells[type] = component;
    };
    /**
     * @param {?} type
     * @return {?}
     */
    CellService.prototype.getCell = /**
     * @param {?} type
     * @return {?}
     */
    function (type) {
        /** @type {?} */
        var component = this.registeredCells[type];
        if (component == null) {
            return TextCellComponent;
        }
        return component;
    };
    return CellService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TableCellComponent = /** @class */ (function () {
    function TableCellComponent(cellService, componentFactoryResolver) {
        this.cellService = cellService;
        this.componentFactoryResolver = componentFactoryResolver;
    }
    /**
     * @return {?}
     */
    TableCellComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.initCell();
    };
    /**
     * @return {?}
     */
    TableCellComponent.prototype.initCell = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var cellComponent = this.cellService.getCell(this.column.type);
        /** @type {?} */
        var componentFactory = this.componentFactoryResolver.resolveComponentFactory(cellComponent);
        /** @type {?} */
        var viewContainerRef = this.cellHost.viewContainerRef;
        viewContainerRef.clear();
        /** @type {?} */
        var componentRef = viewContainerRef.createComponent(componentFactory);
        /** @type {?} */
        var cell = (/** @type {?} */ (componentRef.instance));
        cell.row = this.row;
        cell.column = this.column;
    };
    TableCellComponent.decorators = [
        { type: Component, args: [{
                    selector: 'mdt-table-cell',
                    template: '<ng-template mdtCellHost></ng-template>'
                }] }
    ];
    /** @nocollapse */
    TableCellComponent.ctorParameters = function () { return [
        { type: CellService },
        { type: ComponentFactoryResolver }
    ]; };
    TableCellComponent.propDecorators = {
        cellHost: [{ type: ViewChild, args: [CellDirective,] }],
        row: [{ type: Input }],
        column: [{ type: Input }]
    };
    return TableCellComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DateCellComponent = /** @class */ (function () {
    function DateCellComponent() {
        this.dateFormat = 'short';
    }
    /**
     * @return {?}
     */
    DateCellComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.column.options) {
            if (this.column.options.dateFormat) {
                this.dateFormat = this.column.options.dateFormat;
            }
        }
    };
    DateCellComponent.decorators = [
        { type: Component, args: [{
                    selector: 'mdt-date-cell',
                    template: '{{ row[column.name] | date:dateFormat }}'
                }] }
    ];
    DateCellComponent.propDecorators = {
        column: [{ type: Input }],
        row: [{ type: Input }]
    };
    return DateCellComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DynamicTableModule = /** @class */ (function () {
    function DynamicTableModule(cellService) {
        this.cellService = cellService;
        cellService.registerCell('string', TextCellComponent);
        cellService.registerCell('date', DateCellComponent);
    }
    DynamicTableModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        MatTableModule,
                        MatSortModule,
                        MatPaginatorModule,
                        MatIconModule,
                        MatDialogModule,
                        MatTooltipModule
                    ],
                    declarations: [
                        DynamicTableComponent,
                        TableCellComponent,
                        CellDirective,
                        TextCellComponent,
                        DateCellComponent
                    ],
                    exports: [DynamicTableComponent],
                    entryComponents: [
                        TextCellComponent,
                        DateCellComponent
                    ],
                    providers: [
                        CellService,
                        ColumnFilterService
                    ]
                },] }
    ];
    /** @nocollapse */
    DynamicTableModule.ctorParameters = function () { return [
        { type: CellService }
    ]; };
    return DynamicTableModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { DynamicTableComponent, CellService, CellDirective, ColumnFilterService, ColumnFilter, ColumnConfig, DynamicTableModule, DateCellComponent as ɵc, TextCellComponent as ɵb, TableCellComponent as ɵa };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0ZXJpYWwtZHluYW1pYy10YWJsZS5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vbWF0ZXJpYWwtZHluYW1pYy10YWJsZS9saWIvY29sdW1uLWZpbHRlci5tb2RlbC50cyIsIm5nOi8vbWF0ZXJpYWwtZHluYW1pYy10YWJsZS9saWIvdGFibGUtY2VsbC9jZWxsLXR5cGVzL2NvbHVtbi1maWx0ZXIuc2VydmljZS50cyIsIm5nOi8vbWF0ZXJpYWwtZHluYW1pYy10YWJsZS9saWIvZHluYW1pYy10YWJsZS5jb21wb25lbnQudHMiLCJuZzovL21hdGVyaWFsLWR5bmFtaWMtdGFibGUvbGliL3RhYmxlLWNlbGwvY2VsbC5kaXJlY3RpdmUudHMiLCJuZzovL21hdGVyaWFsLWR5bmFtaWMtdGFibGUvbGliL2NvbHVtbi1jb25maWcubW9kZWwudHMiLCJuZzovL21hdGVyaWFsLWR5bmFtaWMtdGFibGUvbGliL3RhYmxlLWNlbGwvY2VsbC10eXBlcy90ZXh0LWNlbGwuY29tcG9uZW50LnRzIiwibmc6Ly9tYXRlcmlhbC1keW5hbWljLXRhYmxlL2xpYi90YWJsZS1jZWxsL2NlbGwtdHlwZXMvY2VsbC5zZXJ2aWNlLnRzIiwibmc6Ly9tYXRlcmlhbC1keW5hbWljLXRhYmxlL2xpYi90YWJsZS1jZWxsL3RhYmxlLWNlbGwuY29tcG9uZW50LnRzIiwibmc6Ly9tYXRlcmlhbC1keW5hbWljLXRhYmxlL2xpYi90YWJsZS1jZWxsL2NlbGwtdHlwZXMvZGF0ZS1jZWxsLmNvbXBvbmVudC50cyIsIm5nOi8vbWF0ZXJpYWwtZHluYW1pYy10YWJsZS9saWIvZHluYW1pYy10YWJsZS5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29sdW1uQ29uZmlnIH0gZnJvbSAnLi9jb2x1bW4tY29uZmlnLm1vZGVsJztcblxuZXhwb3J0IGNsYXNzIENvbHVtbkZpbHRlciB7XG4gICAgY29sdW1uOiBDb2x1bW5Db25maWc7XG4gICAgZmlsdGVyOiBhbnk7XG59IiwiaW1wb3J0IHsgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5leHBvcnQgY2xhc3MgQ29sdW1uRmlsdGVyU2VydmljZSB7XG5cbiAgICBwcml2YXRlIHJlZ2lzdGVyZWRGaWx0ZXJzOiB7IFtrZXk6IHN0cmluZ106IFR5cGU8YW55PjsgfSA9IHt9O1xuICAgIFxuICAgIHJlZ2lzdGVyRmlsdGVyKHR5cGU6IHN0cmluZywgY29tcG9uZW50OiBUeXBlPGFueT4pIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRmlsdGVyc1t0eXBlXSA9IGNvbXBvbmVudDtcbiAgICB9XG5cbiAgICBnZXRGaWx0ZXIodHlwZTogc3RyaW5nKTogVHlwZTxhbnk+IHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gdGhpcy5yZWdpc3RlcmVkRmlsdGVyc1t0eXBlXTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgfVxufSIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBWaWV3Q2hpbGQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNYXRTb3J0LCBNYXRQYWdpbmF0b3IsIE1hdERpYWxvZywgTWF0RGlhbG9nQ29uZmlnIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xuaW1wb3J0IHsgRGF0YVNvdXJjZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay90YWJsZSc7XG5pbXBvcnQgeyBDb2x1bW5Db25maWcgfSBmcm9tICcuL2NvbHVtbi1jb25maWcubW9kZWwnO1xuaW1wb3J0IHsgQ29sdW1uRmlsdGVyIH0gZnJvbSAnLi9jb2x1bW4tZmlsdGVyLm1vZGVsJztcbmltcG9ydCB7IENvbHVtbkZpbHRlclNlcnZpY2UgfSBmcm9tICcuL3RhYmxlLWNlbGwvY2VsbC10eXBlcy9jb2x1bW4tZmlsdGVyLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdtZHQtZHluYW1pYy10YWJsZScsXG4gIHRlbXBsYXRlVXJsOiAnLi9keW5hbWljLXRhYmxlLmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJy4vZHluYW1pYy10YWJsZS5jb21wb25lbnQuY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgRHluYW1pY1RhYmxlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICBASW5wdXQoKSBjb2x1bW5zOiBDb2x1bW5Db25maWdbXTtcbiAgQElucHV0KCkgZGF0YVNvdXJjZTogRGF0YVNvdXJjZTxhbnk+O1xuICBASW5wdXQoKSBwYWdlU2l6ZSA9IDIwO1xuICBASW5wdXQoKSBwYWdlU2l6ZU9wdGlvbnMgPSBbMjAsIDUwLCAxMDBdO1xuICBASW5wdXQoKSBzaG93RmlsdGVycyA9IHRydWU7XG4gIEBJbnB1dCgpIHN0aWNreUhlYWRlciA9IGZhbHNlO1xuICBASW5wdXQoKSBwYWdpbmF0b3I6IE1hdFBhZ2luYXRvcjtcblxuICBkaXNwbGF5ZWRDb2x1bW5zOiBzdHJpbmdbXTtcblxuICBAVmlld0NoaWxkKE1hdFNvcnQpIHNvcnQ6IE1hdFNvcnQ7XG4gIEBWaWV3Q2hpbGQoTWF0UGFnaW5hdG9yKSBwcml2YXRlIGludGVybmFsUGFnaW5hdG9yOiBNYXRQYWdpbmF0b3I7XG5cbiAgcHJpdmF0ZSBhcHBsaWVkRmlsdGVyczogeyBba2V5OiBzdHJpbmddOiBhbnk7IH0gPSB7fTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGNvbHVtbkZpbHRlclNlcnZpY2U6IENvbHVtbkZpbHRlclNlcnZpY2UsIHByaXZhdGUgcmVhZG9ubHkgZGlhbG9nOiBNYXREaWFsb2cpIHsgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIGlmICh0aGlzLmRhdGFTb3VyY2UgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0R5bmFtaWNUYWJsZSBtdXN0IGJlIHByb3ZpZGVkIHdpdGggZGF0YSBzb3VyY2UuJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbHVtbnMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0R5bmFtaWNUYWJsZSBtdXN0IGJlIHByb3ZpZGVkIHdpdGggY29sdW1uIGRlZmluaXRpb25zLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhZ2luYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnBhZ2luYXRvciA9IHRoaXMuaW50ZXJuYWxQYWdpbmF0b3I7XG4gICAgfVxuXG4gICAgdGhpcy5kaXNwbGF5ZWRDb2x1bW5zID0gdGhpcy5jb2x1bW5zLm1hcCgoY29sdW1uLCBpbmRleCkgPT4gdGhpcy5wcmVwYXJlQ29sdW1uTmFtZShjb2x1bW4ubmFtZSwgaW5kZXgpKTtcblxuICAgIGNvbnN0IGRhdGFTb3VyY2UgPSB0aGlzLmRhdGFTb3VyY2UgYXMgYW55O1xuICAgIGRhdGFTb3VyY2Uuc29ydCA9IHRoaXMuc29ydDtcbiAgICBkYXRhU291cmNlLnBhZ2luYXRvciA9IHRoaXMucGFnaW5hdG9yO1xuICB9XG5cbiAgaXNVc2luZ0ludGVybmFsUGFnaW5hdG9yKCkge1xuICAgIHJldHVybiB0aGlzLnBhZ2luYXRvciA9PT0gdGhpcy5pbnRlcm5hbFBhZ2luYXRvcjtcbiAgfVxuXG4gIGNhbkZpbHRlcihjb2x1bW46IENvbHVtbkNvbmZpZykge1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuY29sdW1uRmlsdGVyU2VydmljZS5nZXRGaWx0ZXIoY29sdW1uLnR5cGUpO1xuXG4gICAgcmV0dXJuIGZpbHRlciAhPSBudWxsO1xuICB9XG5cbiAgaXNGaWx0ZXJlZChjb2x1bW46IENvbHVtbkNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmFwcGxpZWRGaWx0ZXJzW2NvbHVtbi5uYW1lXTtcbiAgfVxuXG4gIGdldEZpbHRlckRlc2NyaXB0aW9uKGNvbHVtbjogQ29sdW1uQ29uZmlnKSB7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy5hcHBsaWVkRmlsdGVyc1tjb2x1bW4ubmFtZV07XG4gICAgaWYgKCFmaWx0ZXIgfHwgIWZpbHRlci5nZXREZXNjcmlwdGlvbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbHRlci5nZXREZXNjcmlwdGlvbigpO1xuICB9XG5cbiAgcHJlcGFyZUNvbHVtbk5hbWUobmFtZTogc3RyaW5nLCBjb2x1bW5OdW1iZXI6IG51bWJlcikge1xuICAgIHJldHVybiBuYW1lIHx8ICdjb2wnICsgY29sdW1uTnVtYmVyO1xuICB9XG5cbiAgZmlsdGVyKGNvbHVtbjogQ29sdW1uQ29uZmlnKSB7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy5jb2x1bW5GaWx0ZXJTZXJ2aWNlLmdldEZpbHRlcihjb2x1bW4udHlwZSk7XG5cbiAgICBpZiAoZmlsdGVyKSB7XG4gICAgICBjb25zdCBkaWFsb2dDb25maWcgPSBuZXcgTWF0RGlhbG9nQ29uZmlnKCk7XG4gICAgICBjb25zdCBjb2x1bW5GaWx0ZXIgPSBuZXcgQ29sdW1uRmlsdGVyKCk7XG4gICAgICBjb2x1bW5GaWx0ZXIuY29sdW1uID0gY29sdW1uO1xuXG4gICAgICBpZiAodGhpcy5hcHBsaWVkRmlsdGVyc1tjb2x1bW4ubmFtZV0pIHtcbiAgICAgICAgY29sdW1uRmlsdGVyLmZpbHRlciA9IE9iamVjdC5jcmVhdGUodGhpcy5hcHBsaWVkRmlsdGVyc1tjb2x1bW4ubmFtZV0pO1xuICAgICAgfVxuXG4gICAgICBkaWFsb2dDb25maWcuZGF0YSA9IGNvbHVtbkZpbHRlcjtcblxuICAgICAgY29uc3QgZGlhbG9nUmVmID0gdGhpcy5kaWFsb2cub3BlbihmaWx0ZXIsIGRpYWxvZ0NvbmZpZyk7XG5cbiAgICAgIGRpYWxvZ1JlZi5hZnRlckNsb3NlZCgpLnN1YnNjcmliZShyZXN1bHQgPT4ge1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgdGhpcy5hcHBsaWVkRmlsdGVyc1tjb2x1bW4ubmFtZV0gPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ID09PSAnJykge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmFwcGxpZWRGaWx0ZXJzW2NvbHVtbi5uYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQgfHwgcmVzdWx0ID09PSAnJykge1xuICAgICAgICAgIHRoaXMudXBkYXRlRGF0YVNvdXJjZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBjbGVhckZpbHRlcnMoKSB7XG4gICAgdGhpcy5hcHBsaWVkRmlsdGVycyA9IHt9O1xuICAgIHRoaXMudXBkYXRlRGF0YVNvdXJjZSgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHVwZGF0ZURhdGFTb3VyY2UoKSB7XG4gICAgY29uc3QgZGF0YVNvdXJjZSA9IHRoaXMuZGF0YVNvdXJjZSBhcyBhbnk7XG4gICAgZGF0YVNvdXJjZS5maWx0ZXJzID0gdGhpcy5nZXRGaWx0ZXJzKCk7XG4gIH1cblxuICBnZXRGaWx0ZXJzKCkge1xuICAgIGNvbnN0IGZpbHRlcnMgPSB0aGlzLmFwcGxpZWRGaWx0ZXJzO1xuICAgIGNvbnN0IGZpbHRlckFycmF5ID0gT2JqZWN0LmtleXMoZmlsdGVycykubWFwKChrZXkpID0+IGZpbHRlcnNba2V5XSk7XG4gICAgcmV0dXJuIGZpbHRlckFycmF5O1xuICB9XG5cbiAgZ2V0RmlsdGVyKGNvbHVtbk5hbWU6IHN0cmluZyk6IGFueSB7XG4gICAgY29uc3QgZmlsdGVyQ29sdW1uID0gdGhpcy5nZXRDb2x1bW5CeU5hbWUoY29sdW1uTmFtZSk7XG5cbiAgICBpZiAoIWZpbHRlckNvbHVtbikge1xuICAgICAgdGhyb3cgRXJyb3IoYENvbHVtbiB3aXRoIG5hbWUgJyR7Y29sdW1uTmFtZX0nIGRvZXMgbm90IGV4aXN0LmApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFwcGxpZWRGaWx0ZXJzW2ZpbHRlckNvbHVtbi5uYW1lXTtcbiAgfVxuXG4gIHNldEZpbHRlcihjb2x1bW5OYW1lOiBzdHJpbmcsIGZpbHRlcjogYW55KSB7XG4gICAgY29uc3QgZmlsdGVyQ29sdW1uID0gdGhpcy5nZXRDb2x1bW5CeU5hbWUoY29sdW1uTmFtZSk7XG5cbiAgICBpZiAoIWZpbHRlckNvbHVtbikge1xuICAgICAgdGhyb3cgRXJyb3IoYENhbm5vdCBzZXQgZmlsdGVyIGZvciBhIGNvbHVtbi4gQ29sdW1uIHdpdGggbmFtZSAnJHtjb2x1bW5OYW1lfScgZG9lcyBub3QgZXhpc3QuYCk7XG4gICAgfVxuXG4gICAgdGhpcy5hcHBsaWVkRmlsdGVyc1tmaWx0ZXJDb2x1bW4ubmFtZV0gPSBmaWx0ZXI7XG4gICAgdGhpcy51cGRhdGVEYXRhU291cmNlKCk7XG4gIH1cblxuICBwcml2YXRlIGdldENvbHVtbkJ5TmFtZShjb2x1bW5OYW1lOiBzdHJpbmcpOiBDb2x1bW5Db25maWcge1xuICAgIHJldHVybiB0aGlzLmNvbHVtbnMuZmluZChjID0+XG4gICAgICAoYy5uYW1lID8gYy5uYW1lLnRvTG93ZXJDYXNlKCkgOiBjLm5hbWUpID09PSAoY29sdW1uTmFtZSA/IGNvbHVtbk5hbWUudG9Mb3dlckNhc2UoKSA6IGNvbHVtbk5hbWUpXG4gICAgKTtcbiAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1ttZHRDZWxsSG9zdF0nLFxufSlcbmV4cG9ydCBjbGFzcyBDZWxsRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZikge31cbn0iLCJleHBvcnQgY2xhc3MgQ29sdW1uQ29uZmlnIHtcclxuICAgIG5hbWU/OiBzdHJpbmc7XHJcbiAgICBkaXNwbGF5TmFtZT86IHN0cmluZztcclxuICAgIHR5cGU6IHN0cmluZztcclxuICAgIG9wdGlvbnM/OiBhbnk7XHJcbiAgICBzdGlja3k/OiBzdHJpbmc7XHJcbiAgICBzb3J0PzogYm9vbGVhbjtcclxufSIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENlbGxDb21wb25lbnQgfSBmcm9tICcuL2NlbGwuY29tcG9uZW50JztcbmltcG9ydCB7IENvbHVtbkNvbmZpZyB9IGZyb20gJy4uLy4uL2NvbHVtbi1jb25maWcubW9kZWwnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ21kdC10ZXh0LWNlbGwnLFxuICAgIHRlbXBsYXRlOiAne3sgcm93W2NvbHVtbi5uYW1lXSB9fSdcbn0pXG5leHBvcnQgY2xhc3MgVGV4dENlbGxDb21wb25lbnQgaW1wbGVtZW50cyBDZWxsQ29tcG9uZW50IHtcbiAgICBASW5wdXQoKSBjb2x1bW46IENvbHVtbkNvbmZpZztcbiAgICBASW5wdXQoKSByb3c6IG9iamVjdDtcbn0iLCJpbXBvcnQgeyBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUZXh0Q2VsbENvbXBvbmVudCB9IGZyb20gJy4vdGV4dC1jZWxsLmNvbXBvbmVudCc7XG5cbmV4cG9ydCBjbGFzcyBDZWxsU2VydmljZSB7XG5cbiAgICBwcml2YXRlIHJlZ2lzdGVyZWRDZWxsczogeyBba2V5OiBzdHJpbmddOiBUeXBlPGFueT47IH0gPSB7fTtcbiAgICBcbiAgICByZWdpc3RlckNlbGwodHlwZTogc3RyaW5nLCBjb21wb25lbnQ6IFR5cGU8YW55Pikge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRDZWxsc1t0eXBlXSA9IGNvbXBvbmVudDtcbiAgICB9XG5cbiAgICBnZXRDZWxsKHR5cGU6IHN0cmluZyk6IFR5cGU8YW55PiB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMucmVnaXN0ZXJlZENlbGxzW3R5cGVdO1xuXG4gICAgICAgIGlmIChjb21wb25lbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFRleHRDZWxsQ29tcG9uZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIElucHV0LCBWaWV3Q2hpbGQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2VsbERpcmVjdGl2ZSB9IGZyb20gJy4vY2VsbC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgQ2VsbFNlcnZpY2UgfSBmcm9tICcuL2NlbGwtdHlwZXMvY2VsbC5zZXJ2aWNlJztcbmltcG9ydCB7IENlbGxDb21wb25lbnQgfSBmcm9tICcuL2NlbGwtdHlwZXMvY2VsbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29sdW1uQ29uZmlnIH0gZnJvbSAnLi4vY29sdW1uLWNvbmZpZy5tb2RlbCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnbWR0LXRhYmxlLWNlbGwnLFxuICAgIHRlbXBsYXRlOiAnPG5nLXRlbXBsYXRlIG1kdENlbGxIb3N0PjwvbmctdGVtcGxhdGU+J1xufSlcbmV4cG9ydCBjbGFzcyBUYWJsZUNlbGxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICAgIEBWaWV3Q2hpbGQoQ2VsbERpcmVjdGl2ZSkgY2VsbEhvc3Q6IENlbGxEaXJlY3RpdmU7XG5cbiAgICBASW5wdXQoKSByb3c6IG9iamVjdDtcbiAgICBASW5wdXQoKSBjb2x1bW46IENvbHVtbkNvbmZpZztcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IGNlbGxTZXJ2aWNlOiBDZWxsU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcikgeyB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5pbml0Q2VsbCgpO1xuICAgIH1cblxuICAgIGluaXRDZWxsKCkge1xuICAgICAgICBjb25zdCBjZWxsQ29tcG9uZW50ID0gdGhpcy5jZWxsU2VydmljZS5nZXRDZWxsKHRoaXMuY29sdW1uLnR5cGUpO1xuICAgICAgICBjb25zdCBjb21wb25lbnRGYWN0b3J5ID0gdGhpcy5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoY2VsbENvbXBvbmVudCk7XG4gICAgICAgIGNvbnN0IHZpZXdDb250YWluZXJSZWYgPSB0aGlzLmNlbGxIb3N0LnZpZXdDb250YWluZXJSZWY7XG4gICAgICAgIHZpZXdDb250YWluZXJSZWYuY2xlYXIoKTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50UmVmID0gdmlld0NvbnRhaW5lclJlZi5jcmVhdGVDb21wb25lbnQoY29tcG9uZW50RmFjdG9yeSk7XG4gICAgICAgIGNvbnN0IGNlbGwgPSBjb21wb25lbnRSZWYuaW5zdGFuY2UgYXMgQ2VsbENvbXBvbmVudDtcbiAgICAgICAgY2VsbC5yb3cgPSB0aGlzLnJvdztcbiAgICAgICAgY2VsbC5jb2x1bW4gPSB0aGlzLmNvbHVtbjtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDZWxsQ29tcG9uZW50IH0gZnJvbSAnLi9jZWxsLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb2x1bW5Db25maWcgfSBmcm9tICcuLi8uLi9jb2x1bW4tY29uZmlnLm1vZGVsJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdtZHQtZGF0ZS1jZWxsJyxcbiAgICB0ZW1wbGF0ZTogJ3t7IHJvd1tjb2x1bW4ubmFtZV0gfCBkYXRlOmRhdGVGb3JtYXQgfX0nXG59KVxuZXhwb3J0IGNsYXNzIERhdGVDZWxsQ29tcG9uZW50IGltcGxlbWVudHMgQ2VsbENvbXBvbmVudCwgT25Jbml0IHtcbiAgICBASW5wdXQoKSBjb2x1bW46IENvbHVtbkNvbmZpZztcbiAgICBASW5wdXQoKSByb3c6IG9iamVjdDtcblxuICAgIGRhdGVGb3JtYXQgPSAnc2hvcnQnO1xuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbi5vcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2x1bW4ub3B0aW9ucy5kYXRlRm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRlRm9ybWF0ID0gdGhpcy5jb2x1bW4ub3B0aW9ucy5kYXRlRm9ybWF0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5pbXBvcnQge1xuICBNYXRUYWJsZU1vZHVsZSxcbiAgTWF0U29ydE1vZHVsZSxcbiAgTWF0UGFnaW5hdG9yTW9kdWxlLFxuICBNYXRJY29uTW9kdWxlLFxuICBNYXREaWFsb2dNb2R1bGUsXG4gIE1hdFRvb2x0aXBNb2R1bGVcbn0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xuXG5pbXBvcnQgeyBEeW5hbWljVGFibGVDb21wb25lbnQgfSBmcm9tICcuL2R5bmFtaWMtdGFibGUuY29tcG9uZW50JztcbmltcG9ydCB7IFRhYmxlQ2VsbENvbXBvbmVudCB9IGZyb20gJy4vdGFibGUtY2VsbC90YWJsZS1jZWxsLmNvbXBvbmVudCc7XG5cbmltcG9ydCB7IENlbGxTZXJ2aWNlIH0gZnJvbSAnLi90YWJsZS1jZWxsL2NlbGwtdHlwZXMvY2VsbC5zZXJ2aWNlJztcbmltcG9ydCB7IENlbGxEaXJlY3RpdmUgfSBmcm9tICcuL3RhYmxlLWNlbGwvY2VsbC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgQ29sdW1uRmlsdGVyU2VydmljZSB9IGZyb20gJy4vdGFibGUtY2VsbC9jZWxsLXR5cGVzL2NvbHVtbi1maWx0ZXIuc2VydmljZSc7XG5cbmV4cG9ydCB7IENlbGxTZXJ2aWNlLCBDZWxsRGlyZWN0aXZlLCBDb2x1bW5GaWx0ZXJTZXJ2aWNlIH07XG5leHBvcnQgeyBDZWxsQ29tcG9uZW50IH0gZnJvbSAnLi90YWJsZS1jZWxsL2NlbGwtdHlwZXMvY2VsbC5jb21wb25lbnQnO1xuZXhwb3J0IHsgQ29sdW1uRmlsdGVyIH0gZnJvbSAnLi9jb2x1bW4tZmlsdGVyLm1vZGVsJztcbmV4cG9ydCB7IENvbHVtbkNvbmZpZyB9IGZyb20gJy4vY29sdW1uLWNvbmZpZy5tb2RlbCc7XG5leHBvcnQgeyBGaWx0ZXJEZXNjcmlwdGlvbiB9IGZyb20gJy4vZmlsdGVyLWRlc2NyaXB0aW9uJztcblxuaW1wb3J0IHsgVGV4dENlbGxDb21wb25lbnQgfSBmcm9tICcuL3RhYmxlLWNlbGwvY2VsbC10eXBlcy90ZXh0LWNlbGwuY29tcG9uZW50JztcbmltcG9ydCB7IERhdGVDZWxsQ29tcG9uZW50IH0gZnJvbSAnLi90YWJsZS1jZWxsL2NlbGwtdHlwZXMvZGF0ZS1jZWxsLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtcbiAgICBDb21tb25Nb2R1bGUsXG4gICAgTWF0VGFibGVNb2R1bGUsXG4gICAgTWF0U29ydE1vZHVsZSxcbiAgICBNYXRQYWdpbmF0b3JNb2R1bGUsXG4gICAgTWF0SWNvbk1vZHVsZSxcbiAgICBNYXREaWFsb2dNb2R1bGUsXG4gICAgTWF0VG9vbHRpcE1vZHVsZVxuICBdLFxuICBkZWNsYXJhdGlvbnM6IFtcbiAgICBEeW5hbWljVGFibGVDb21wb25lbnQsXG4gICAgVGFibGVDZWxsQ29tcG9uZW50LFxuICAgIENlbGxEaXJlY3RpdmUsXG4gICAgVGV4dENlbGxDb21wb25lbnQsXG4gICAgRGF0ZUNlbGxDb21wb25lbnRcbiAgXSxcbiAgZXhwb3J0czogW0R5bmFtaWNUYWJsZUNvbXBvbmVudF0sXG4gIGVudHJ5Q29tcG9uZW50czogW1xuICAgIFRleHRDZWxsQ29tcG9uZW50LFxuICAgIERhdGVDZWxsQ29tcG9uZW50XG4gIF0sXG4gIHByb3ZpZGVyczogW1xuICAgIENlbGxTZXJ2aWNlLFxuICAgIENvbHVtbkZpbHRlclNlcnZpY2VcbiAgXVxufSlcbmV4cG9ydCBjbGFzcyBEeW5hbWljVGFibGVNb2R1bGUge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGNlbGxTZXJ2aWNlOiBDZWxsU2VydmljZSkge1xuICAgIGNlbGxTZXJ2aWNlLnJlZ2lzdGVyQ2VsbCgnc3RyaW5nJywgVGV4dENlbGxDb21wb25lbnQpO1xuICAgIGNlbGxTZXJ2aWNlLnJlZ2lzdGVyQ2VsbCgnZGF0ZScsIERhdGVDZWxsQ29tcG9uZW50KTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUVBO0lBQUE7S0FHQztJQUFELG1CQUFDO0NBQUE7Ozs7OztBQ0hEO0lBQUE7UUFFWSxzQkFBaUIsR0FBa0MsRUFBRSxDQUFDO0tBV2pFOzs7Ozs7SUFURyw0Q0FBYzs7Ozs7SUFBZCxVQUFlLElBQVksRUFBRSxTQUFvQjtRQUM3QyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEdBQUcsU0FBUyxDQUFDO0tBQzVDOzs7OztJQUVELHVDQUFTOzs7O0lBQVQsVUFBVSxJQUFZOztZQUNaLFNBQVMsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDO1FBRTlDLE9BQU8sU0FBUyxDQUFDO0tBQ3BCO0lBQ0wsMEJBQUM7Q0FBQTs7Ozs7O0FDZkQ7SUE2QkUsK0JBQTZCLG1CQUF3QyxFQUFtQixNQUFpQjtRQUE1RSx3QkFBbUIsR0FBbkIsbUJBQW1CLENBQXFCO1FBQW1CLFdBQU0sR0FBTixNQUFNLENBQVc7UUFiaEcsYUFBUSxHQUFHLEVBQUUsQ0FBQztRQUNkLG9CQUFlLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ2hDLGdCQUFXLEdBQUcsSUFBSSxDQUFDO1FBQ25CLGlCQUFZLEdBQUcsS0FBSyxDQUFDO1FBUXRCLG1CQUFjLEdBQTRCLEVBQUUsQ0FBQztLQUV5RDs7OztJQUU5Ryx3Q0FBUTs7O0lBQVI7UUFBQSxpQkFpQkM7UUFoQkMsSUFBSSxJQUFJLENBQUMsVUFBVSxJQUFJLElBQUksRUFBRTtZQUMzQixNQUFNLEtBQUssQ0FBQyxpREFBaUQsQ0FBQyxDQUFDO1NBQ2hFO1FBQ0QsSUFBSSxJQUFJLENBQUMsT0FBTyxJQUFJLElBQUksRUFBRTtZQUN4QixN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