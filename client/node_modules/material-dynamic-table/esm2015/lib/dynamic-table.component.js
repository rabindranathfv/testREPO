/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ViewChild, Input } from '@angular/core';
import { MatSort, MatPaginator, MatDialog, MatDialogConfig } from '@angular/material';
import { DataSource } from '@angular/cdk/table';
import { ColumnFilter } from './column-filter.model';
import { ColumnFilterService } from './table-cell/cell-types/column-filter.service';
export class DynamicTableComponent {
    /**
     * @param {?} columnFilterService
     * @param {?} dialog
     */
    constructor(columnFilterService, dialog) {
        this.columnFilterService = columnFilterService;
        this.dialog = dialog;
        this.pageSize = 20;
        this.pageSizeOptions = [20, 50, 100];
        this.showFilters = true;
        this.stickyHeader = false;
        this.appliedFilters = {};
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.dataSource == null) {
            throw Error('DynamicTable must be provided with data source.');
        }
        if (this.columns == null) {
            throw Error('DynamicTable must be provided with column definitions.');
        }
        if (this.paginator === undefined) {
            this.paginator = this.internalPaginator;
        }
        this.displayedColumns = this.columns.map((column, index) => this.prepareColumnName(column.name, index));
        /** @type {?} */
        const dataSource = (/** @type {?} */ (this.dataSource));
        dataSource.sort = this.sort;
        dataSource.paginator = this.paginator;
    }
    /**
     * @return {?}
     */
    isUsingInternalPaginator() {
        return this.paginator === this.internalPaginator;
    }
    /**
     * @param {?} column
     * @return {?}
     */
    canFilter(column) {
        /** @type {?} */
        const filter = this.columnFilterService.getFilter(column.type);
        return filter != null;
    }
    /**
     * @param {?} column
     * @return {?}
     */
    isFiltered(column) {
        return this.appliedFilters[column.name];
    }
    /**
     * @param {?} column
     * @return {?}
     */
    getFilterDescription(column) {
        /** @type {?} */
        const filter = this.appliedFilters[column.name];
        if (!filter || !filter.getDescription) {
            return null;
        }
        return filter.getDescription();
    }
    /**
     * @param {?} name
     * @param {?} columnNumber
     * @return {?}
     */
    prepareColumnName(name, columnNumber) {
        return name || 'col' + columnNumber;
    }
    /**
     * @param {?} column
     * @return {?}
     */
    filter(column) {
        /** @type {?} */
        const filter = this.columnFilterService.getFilter(column.type);
        if (filter) {
            /** @type {?} */
            const dialogConfig = new MatDialogConfig();
            /** @type {?} */
            const columnFilter = new ColumnFilter();
            columnFilter.column = column;
            if (this.appliedFilters[column.name]) {
                columnFilter.filter = Object.create(this.appliedFilters[column.name]);
            }
            dialogConfig.data = columnFilter;
            /** @type {?} */
            const dialogRef = this.dialog.open(filter, dialogConfig);
            dialogRef.afterClosed().subscribe(result => {
                if (result) {
                    this.appliedFilters[column.name] = result;
                }
                else if (result === '') {
                    delete this.appliedFilters[column.name];
                }
                if (result || result === '') {
                    this.updateDataSource();
                }
            });
        }
    }
    /**
     * @return {?}
     */
    clearFilters() {
        this.appliedFilters = {};
        this.updateDataSource();
    }
    /**
     * @protected
     * @return {?}
     */
    updateDataSource() {
        /** @type {?} */
        const dataSource = (/** @type {?} */ (this.dataSource));
        dataSource.filters = this.getFilters();
    }
    /**
     * @return {?}
     */
    getFilters() {
        /** @type {?} */
        const filters = this.appliedFilters;
        /** @type {?} */
        const filterArray = Object.keys(filters).map((key) => filters[key]);
        return filterArray;
    }
    /**
     * @param {?} columnName
     * @return {?}
     */
    getFilter(columnName) {
        /** @type {?} */
        const filterColumn = this.getColumnByName(columnName);
        if (!filterColumn) {
            throw Error(`Column with name '${columnName}' does not exist.`);
        }
        return this.appliedFilters[filterColumn.name];
    }
    /**
     * @param {?} columnName
     * @param {?} filter
     * @return {?}
     */
    setFilter(columnName, filter) {
        /** @type {?} */
        const filterColumn = this.getColumnByName(columnName);
        if (!filterColumn) {
            throw Error(`Cannot set filter for a column. Column with name '${columnName}' does not exist.`);
        }
        this.appliedFilters[filterColumn.name] = filter;
        this.updateDataSource();
    }
    /**
     * @private
     * @param {?} columnName
     * @return {?}
     */
    getColumnByName(columnName) {
        return this.columns.find(c => (c.name ? c.name.toLowerCase() : c.name) === (columnName ? columnName.toLowerCase() : columnName));
    }
}
DynamicTableComponent.decorators = [
    { type: Component, args: [{
                selector: 'mdt-dynamic-table',
                template: "<table mat-table [dataSource]=\"dataSource\"\r\n       matSort matSortDirection=\"asc\">\r\n\r\n  <ng-container *ngFor=\"let column of columns; let i = index\" matColumnDef=\"{{ prepareColumnName(column.name, i) }}\"\r\n                [sticky]=\"column.sticky === 'start'\" [stickyEnd]=\"column.sticky === 'end'\">\r\n    <th mat-header-cell *matHeaderCellDef mat-sort-header=\"{{ prepareColumnName(column.name, i) }}\" [disabled]=\"!column.name || column.sort === false\">\r\n      {{ column.displayName }}\r\n      <button class=\"mat-sort-header-button\" *ngIf=\"showFilters && canFilter(column)\"\r\n              (click)=\"filter(column); $event.stopPropagation();\"\r\n              matTooltip=\"{{ getFilterDescription(column) }}\" matTooltipDisabled=\"{{ !getFilterDescription(column) }}\">\r\n        <mat-icon color=\"{{ isFiltered(column) ? 'primary' : 'default' }}\">filter_list</mat-icon>\r\n      </button>\r\n    </th>\r\n    <td mat-cell *matCellDef=\"let row\"><mdt-table-cell [row]=\"row\" [column]=\"column\"></mdt-table-cell></td>\r\n  </ng-container>\r\n\r\n  <tr mat-header-row *matHeaderRowDef=\"displayedColumns; sticky: [stickyHeader]\"></tr>\r\n  <tr mat-row *matRowDef=\"let row; columns: displayedColumns;\"></tr>\r\n</table>\r\n<mat-paginator [hidden]=\"!isUsingInternalPaginator()\" [pageSize]=\"pageSize\"\r\n               [pageSizeOptions]=\"pageSizeOptions\">\r\n</mat-paginator>",
                styles: ["table{width:100%}th .mat-icon.mat-default{opacity:.54}th .mat-icon.mat-default:hover{opacity:1}[hidden]{display:none}"]
            }] }
];
/** @nocollapse */
DynamicTableComponent.ctorParameters = () => [
    { type: ColumnFilterService },
    { type: MatDialog }
];
DynamicTableComponent.propDecorators = {
    columns: [{ type: Input }],
    dataSource: [{ type: Input }],
    pageSize: [{ type: Input }],
    pageSizeOptions: [{ type: Input }],
    showFilters: [{ type: Input }],
    stickyHeader: [{ type: Input }],
    paginator: [{ type: Input }],
    sort: [{ type: ViewChild, args: [MatSort,] }],
    internalPaginator: [{ type: ViewChild, args: [MatPaginator,] }]
};
if (false) {
    /** @type {?} */
    DynamicTableComponent.prototype.columns;
    /** @type {?} */
    DynamicTableComponent.prototype.dataSource;
    /** @type {?} */
    DynamicTableComponent.prototype.pageSize;
    /** @type {?} */
    DynamicTableComponent.prototype.pageSizeOptions;
    /** @type {?} */
    DynamicTableComponent.prototype.showFilters;
    /** @type {?} */
    DynamicTableComponent.prototype.stickyHeader;
    /** @type {?} */
    DynamicTableComponent.prototype.paginator;
    /** @type {?} */
    DynamicTableComponent.prototype.displayedColumns;
    /** @type {?} */
    DynamicTableComponent.prototype.sort;
    /**
     * @type {?}
     * @private
     */
    DynamicTableComponent.prototype.internalPaginator;
    /**
     * @type {?}
     * @private
     */
    DynamicTableComponent.prototype.appliedFilters;
    /**
     * @type {?}
     * @private
     */
    DynamicTableComponent.prototype.columnFilterService;
    /**
     * @type {?}
     * @private
     */
    DynamicTableComponent.prototype.dialog;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHluYW1pYy10YWJsZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9tYXRlcmlhbC1keW5hbWljLXRhYmxlLyIsInNvdXJjZXMiOlsibGliL2R5bmFtaWMtdGFibGUuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFVLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDcEUsT0FBTyxFQUFFLE9BQU8sRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLGVBQWUsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ3RGLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUVoRCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDckQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sK0NBQStDLENBQUM7QUFPcEYsTUFBTSxPQUFPLHFCQUFxQjs7Ozs7SUFpQmhDLFlBQTZCLG1CQUF3QyxFQUFtQixNQUFpQjtRQUE1RSx3QkFBbUIsR0FBbkIsbUJBQW1CLENBQXFCO1FBQW1CLFdBQU0sR0FBTixNQUFNLENBQVc7UUFiaEcsYUFBUSxHQUFHLEVBQUUsQ0FBQztRQUNkLG9CQUFlLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ2hDLGdCQUFXLEdBQUcsSUFBSSxDQUFDO1FBQ25CLGlCQUFZLEdBQUcsS0FBSyxDQUFDO1FBUXRCLG1CQUFjLEdBQTRCLEVBQUUsQ0FBQztJQUV3RCxDQUFDOzs7O0lBRTlHLFFBQVE7UUFDTixJQUFJLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxFQUFFO1lBQzNCLE1BQU0sS0FBSyxDQUFDLGlEQUFpRCxDQUFDLENBQUM7U0FDaEU7UUFDRCxJQUFJLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxFQUFFO1lBQ3hCLE1BQU0sS0FBSyxDQUFDLHdEQUF3RCxDQUFDLENBQUM7U0FD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QkFBZ0IsRUFBRSxDQUFDO0lBQzFCLENBQUM7Ozs7OztJQUVPLGVBQWUsQ0FBQyxVQUFrQjtRQUN4QyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQzNCLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUNsRyxDQUFDO0lBQ0osQ0FBQzs7O1lBN0lGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsbUJBQW1CO2dCQUM3QixrNUNBQTZDOzthQUU5Qzs7OztZQU5RLG1CQUFtQjtZQUpJLFNBQVM7OztzQkFhdEMsS0FBSzt5QkFDTCxLQUFLO3VCQUNMLEtBQUs7OEJBQ0wsS0FBSzswQkFDTCxLQUFLOzJCQUNMLEtBQUs7d0JBQ0wsS0FBSzttQkFJTCxTQUFTLFNBQUMsT0FBTztnQ0FDakIsU0FBUyxTQUFDLFlBQVk7Ozs7SUFYdkIsd0NBQWlDOztJQUNqQywyQ0FBcUM7O0lBQ3JDLHlDQUF1Qjs7SUFDdkIsZ0RBQXlDOztJQUN6Qyw0Q0FBNEI7O0lBQzVCLDZDQUE4Qjs7SUFDOUIsMENBQWlDOztJQUVqQyxpREFBMkI7O0lBRTNCLHFDQUFrQzs7Ozs7SUFDbEMsa0RBQWlFOzs7OztJQUVqRSwrQ0FBcUQ7Ozs7O0lBRXpDLG9EQUF5RDs7Ozs7SUFBRSx1Q0FBa0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCwgVmlld0NoaWxkLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWF0U29ydCwgTWF0UGFnaW5hdG9yLCBNYXREaWFsb2csIE1hdERpYWxvZ0NvbmZpZyB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcbmltcG9ydCB7IERhdGFTb3VyY2UgfSBmcm9tICdAYW5ndWxhci9jZGsvdGFibGUnO1xuaW1wb3J0IHsgQ29sdW1uQ29uZmlnIH0gZnJvbSAnLi9jb2x1bW4tY29uZmlnLm1vZGVsJztcbmltcG9ydCB7IENvbHVtbkZpbHRlciB9IGZyb20gJy4vY29sdW1uLWZpbHRlci5tb2RlbCc7XG5pbXBvcnQgeyBDb2x1bW5GaWx0ZXJTZXJ2aWNlIH0gZnJvbSAnLi90YWJsZS1jZWxsL2NlbGwtdHlwZXMvY29sdW1uLWZpbHRlci5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbWR0LWR5bmFtaWMtdGFibGUnLFxuICB0ZW1wbGF0ZVVybDogJy4vZHluYW1pYy10YWJsZS5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL2R5bmFtaWMtdGFibGUuY29tcG9uZW50LmNzcyddXG59KVxuZXhwb3J0IGNsYXNzIER5bmFtaWNUYWJsZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgQElucHV0KCkgY29sdW1uczogQ29sdW1uQ29uZmlnW107XG4gIEBJbnB1dCgpIGRhdGFTb3VyY2U6IERhdGFTb3VyY2U8YW55PjtcbiAgQElucHV0KCkgcGFnZVNpemUgPSAyMDtcbiAgQElucHV0KCkgcGFnZVNpemVPcHRpb25zID0gWzIwLCA1MCwgMTAwXTtcbiAgQElucHV0KCkgc2hvd0ZpbHRlcnMgPSB0cnVlO1xuICBASW5wdXQoKSBzdGlja3lIZWFkZXIgPSBmYWxzZTtcbiAgQElucHV0KCkgcGFnaW5hdG9yOiBNYXRQYWdpbmF0b3I7XG5cbiAgZGlzcGxheWVkQ29sdW1uczogc3RyaW5nW107XG5cbiAgQFZpZXdDaGlsZChNYXRTb3J0KSBzb3J0OiBNYXRTb3J0O1xuICBAVmlld0NoaWxkKE1hdFBhZ2luYXRvcikgcHJpdmF0ZSBpbnRlcm5hbFBhZ2luYXRvcjogTWF0UGFnaW5hdG9yO1xuXG4gIHByaXZhdGUgYXBwbGllZEZpbHRlcnM6IHsgW2tleTogc3RyaW5nXTogYW55OyB9ID0ge307XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBjb2x1bW5GaWx0ZXJTZXJ2aWNlOiBDb2x1bW5GaWx0ZXJTZXJ2aWNlLCBwcml2YXRlIHJlYWRvbmx5IGRpYWxvZzogTWF0RGlhbG9nKSB7IH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICBpZiAodGhpcy5kYXRhU291cmNlID09IG51bGwpIHtcbiAgICAgIHRocm93IEVycm9yKCdEeW5hbWljVGFibGUgbXVzdCBiZSBwcm92aWRlZCB3aXRoIGRhdGEgc291cmNlLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb2x1bW5zID09IG51bGwpIHtcbiAgICAgIHRocm93IEVycm9yKCdEeW5hbWljVGFibGUgbXVzdCBiZSBwcm92aWRlZCB3aXRoIGNvbHVtbiBkZWZpbml0aW9ucy4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYWdpbmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5wYWdpbmF0b3IgPSB0aGlzLmludGVybmFsUGFnaW5hdG9yO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGxheWVkQ29sdW1ucyA9IHRoaXMuY29sdW1ucy5tYXAoKGNvbHVtbiwgaW5kZXgpID0+IHRoaXMucHJlcGFyZUNvbHVtbk5hbWUoY29sdW1uLm5hbWUsIGluZGV4KSk7XG5cbiAgICBjb25zdCBkYXRhU291cmNlID0gdGhpcy5kYXRhU291cmNlIGFzIGFueTtcbiAgICBkYXRhU291cmNlLnNvcnQgPSB0aGlzLnNvcnQ7XG4gICAgZGF0YVNvdXJjZS5wYWdpbmF0b3IgPSB0aGlzLnBhZ2luYXRvcjtcbiAgfVxuXG4gIGlzVXNpbmdJbnRlcm5hbFBhZ2luYXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5wYWdpbmF0b3IgPT09IHRoaXMuaW50ZXJuYWxQYWdpbmF0b3I7XG4gIH1cblxuICBjYW5GaWx0ZXIoY29sdW1uOiBDb2x1bW5Db25maWcpIHtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLmNvbHVtbkZpbHRlclNlcnZpY2UuZ2V0RmlsdGVyKGNvbHVtbi50eXBlKTtcblxuICAgIHJldHVybiBmaWx0ZXIgIT0gbnVsbDtcbiAgfVxuXG4gIGlzRmlsdGVyZWQoY29sdW1uOiBDb2x1bW5Db25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5hcHBsaWVkRmlsdGVyc1tjb2x1bW4ubmFtZV07XG4gIH1cblxuICBnZXRGaWx0ZXJEZXNjcmlwdGlvbihjb2x1bW46IENvbHVtbkNvbmZpZykge1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuYXBwbGllZEZpbHRlcnNbY29sdW1uLm5hbWVdO1xuICAgIGlmICghZmlsdGVyIHx8ICFmaWx0ZXIuZ2V0RGVzY3JpcHRpb24pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBmaWx0ZXIuZ2V0RGVzY3JpcHRpb24oKTtcbiAgfVxuXG4gIHByZXBhcmVDb2x1bW5OYW1lKG5hbWU6IHN0cmluZywgY29sdW1uTnVtYmVyOiBudW1iZXIpIHtcbiAgICByZXR1cm4gbmFtZSB8fCAnY29sJyArIGNvbHVtbk51bWJlcjtcbiAgfVxuXG4gIGZpbHRlcihjb2x1bW46IENvbHVtbkNvbmZpZykge1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuY29sdW1uRmlsdGVyU2VydmljZS5nZXRGaWx0ZXIoY29sdW1uLnR5cGUpO1xuXG4gICAgaWYgKGZpbHRlcikge1xuICAgICAgY29uc3QgZGlhbG9nQ29uZmlnID0gbmV3IE1hdERpYWxvZ0NvbmZpZygpO1xuICAgICAgY29uc3QgY29sdW1uRmlsdGVyID0gbmV3IENvbHVtbkZpbHRlcigpO1xuICAgICAgY29sdW1uRmlsdGVyLmNvbHVtbiA9IGNvbHVtbjtcblxuICAgICAgaWYgKHRoaXMuYXBwbGllZEZpbHRlcnNbY29sdW1uLm5hbWVdKSB7XG4gICAgICAgIGNvbHVtbkZpbHRlci5maWx0ZXIgPSBPYmplY3QuY3JlYXRlKHRoaXMuYXBwbGllZEZpbHRlcnNbY29sdW1uLm5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgZGlhbG9nQ29uZmlnLmRhdGEgPSBjb2x1bW5GaWx0ZXI7XG5cbiAgICAgIGNvbnN0IGRpYWxvZ1JlZiA9IHRoaXMuZGlhbG9nLm9wZW4oZmlsdGVyLCBkaWFsb2dDb25maWcpO1xuXG4gICAgICBkaWFsb2dSZWYuYWZ0ZXJDbG9zZWQoKS5zdWJzY3JpYmUocmVzdWx0ID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHRoaXMuYXBwbGllZEZpbHRlcnNbY29sdW1uLm5hbWVdID0gcmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gJycpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5hcHBsaWVkRmlsdGVyc1tjb2x1bW4ubmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0IHx8IHJlc3VsdCA9PT0gJycpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZURhdGFTb3VyY2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgY2xlYXJGaWx0ZXJzKCkge1xuICAgIHRoaXMuYXBwbGllZEZpbHRlcnMgPSB7fTtcbiAgICB0aGlzLnVwZGF0ZURhdGFTb3VyY2UoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCB1cGRhdGVEYXRhU291cmNlKCkge1xuICAgIGNvbnN0IGRhdGFTb3VyY2UgPSB0aGlzLmRhdGFTb3VyY2UgYXMgYW55O1xuICAgIGRhdGFTb3VyY2UuZmlsdGVycyA9IHRoaXMuZ2V0RmlsdGVycygpO1xuICB9XG5cbiAgZ2V0RmlsdGVycygpIHtcbiAgICBjb25zdCBmaWx0ZXJzID0gdGhpcy5hcHBsaWVkRmlsdGVycztcbiAgICBjb25zdCBmaWx0ZXJBcnJheSA9IE9iamVjdC5rZXlzKGZpbHRlcnMpLm1hcCgoa2V5KSA9PiBmaWx0ZXJzW2tleV0pO1xuICAgIHJldHVybiBmaWx0ZXJBcnJheTtcbiAgfVxuXG4gIGdldEZpbHRlcihjb2x1bW5OYW1lOiBzdHJpbmcpOiBhbnkge1xuICAgIGNvbnN0IGZpbHRlckNvbHVtbiA9IHRoaXMuZ2V0Q29sdW1uQnlOYW1lKGNvbHVtbk5hbWUpO1xuXG4gICAgaWYgKCFmaWx0ZXJDb2x1bW4pIHtcbiAgICAgIHRocm93IEVycm9yKGBDb2x1bW4gd2l0aCBuYW1lICcke2NvbHVtbk5hbWV9JyBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hcHBsaWVkRmlsdGVyc1tmaWx0ZXJDb2x1bW4ubmFtZV07XG4gIH1cblxuICBzZXRGaWx0ZXIoY29sdW1uTmFtZTogc3RyaW5nLCBmaWx0ZXI6IGFueSkge1xuICAgIGNvbnN0IGZpbHRlckNvbHVtbiA9IHRoaXMuZ2V0Q29sdW1uQnlOYW1lKGNvbHVtbk5hbWUpO1xuXG4gICAgaWYgKCFmaWx0ZXJDb2x1bW4pIHtcbiAgICAgIHRocm93IEVycm9yKGBDYW5ub3Qgc2V0IGZpbHRlciBmb3IgYSBjb2x1bW4uIENvbHVtbiB3aXRoIG5hbWUgJyR7Y29sdW1uTmFtZX0nIGRvZXMgbm90IGV4aXN0LmApO1xuICAgIH1cblxuICAgIHRoaXMuYXBwbGllZEZpbHRlcnNbZmlsdGVyQ29sdW1uLm5hbWVdID0gZmlsdGVyO1xuICAgIHRoaXMudXBkYXRlRGF0YVNvdXJjZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRDb2x1bW5CeU5hbWUoY29sdW1uTmFtZTogc3RyaW5nKTogQ29sdW1uQ29uZmlnIHtcbiAgICByZXR1cm4gdGhpcy5jb2x1bW5zLmZpbmQoYyA9PlxuICAgICAgKGMubmFtZSA/IGMubmFtZS50b0xvd2VyQ2FzZSgpIDogYy5uYW1lKSA9PT0gKGNvbHVtbk5hbWUgPyBjb2x1bW5OYW1lLnRvTG93ZXJDYXNlKCkgOiBjb2x1bW5OYW1lKVxuICAgICk7XG4gIH1cbn0iXX0=